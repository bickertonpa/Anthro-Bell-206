---
title: "Bell 206 Anthro Accommodation"
author: "Patrick Bickerton"
date: "2025-05-31"
output: 
  prettydoc::html_pretty:
    toc: true
    toc_depth: 2
    theme: hpstr
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The design and evaluation of crewstations, such as helicopter cockpits, must address the challenge of accommodating a diverse range of body sizes. In military aviation, this issue has traditionally been managed by setting anthropometric entry requirements that narrow the pool of eligible pilots. However, evolving policy and operational demands—such as efforts to diversify aircrew populations—have renewed focus on optimizing cockpit designs for broader anthropometric inclusion. This R Markdown document presents a cockpit accommodation mapping analysis for the Bell 206 Helicopter, leveraging the methodology presented by Zehner (2001). The aim is to provide both technical documentation and an instructional resource that integrates anthropometric data, analytical code, and visualization.

# Methodological Overview

The methodological framework used for this study mirrors the structured approach defined by Zehner (2001), comprising the following steps:

* Defining the User Population: We selected a representative anthropometric sample from the available dataset, filtered to reflect the demographic and physical characteristics of prospective rotary-wing pilots. This includes stature, sitting height, and buttock-knee length, which are known to influence cockpit accommodation. We also separate analyses by sex.

* Identifying Operational Requirements: Functional reach, visibility (especially over-the-nose vision), and control actuation were defined as essential operational criteria for the Bell 206. These would normally be informed by pilot interviews, historical ergonomics literature, and observed control configurations in the aircraft. However, for the present effort, these were arbitrarily defined by the test team to prioritize the training opportunity.

* Cockpit Mapping: Anthropometric variables were mapped against cockpit features using regression modeling. Accommodation success was evaluated by comparing predicted values—such as eye height or functional reach—against thresholds necessary to operate the helicopter safely.

* Predicting Population-Level Accommodation: Using population percentile data and regression models, we estimated the percentage of the population likely to be accommodated within the existing cockpit geometry.

Each of these phases is documented in this R Markdown file, with corresponding code, figures, and summaries provided inline.

# Anthropometric Dataset Description
The analysis draws from a curated subset of anthropometric data representative of the potential user population. Data selection emphasized key dimensions affecting cockpit fit, including the "core six":

* Sitting Height, (for head clearance to overhead control panel),

* Eye Height, Sitting (for vision clearance),

* Acromial Height, Sitting (for control alignment and clearance assessments),

* Buttock-Knee Length (for legroom and pedal reach),

* Knee Height, Sitting (for legroom and pedal reach),

* Thumbtip Reach (for lateral and forward reach envelope),

Additional anthropometric measurements were taken for exploratory purposes.

All data cleaning and filtering steps are documented in the accompanying code chunks. Where applicable, outlier handling and dimension normalization were performed to align with assumptions of multivariate modeling.

# Libraries and Custom Functions

Before proceeding with the analysis, we begin by loading the necessary R packages and sourcing a set of custom functions used across multiple anthropometric accommodation projects. These functions are modular and have been developed to streamline common tasks such as data cleaning, cockpit geometry transformation, percentile calculation, and visualization.

The following code chunk performs two key functions:

1. Load Required Libraries: Core packages such as tidyverse for data manipulation and plotting, readr and googlesheets 4 for file input, and ggplot2 for visualizations are loaded.

2. Source Custom Functions: Custom R scripts are sourced to make reusable functions available in the current environment. These scripts contain purpose-built code for cockpit fit assessments—such as functions to compute univariate percentiles of the participants compared to a population data set.

This initialization step ensures a consistent analytical environment and supports reproducibility across cockpit accommodation studies.

```{r}
# import the libraries
library(tidyr)
library(ggplot2)
library(readr)
library(dplyr)
library(psych) #for principle component analysis with VARIMAX rotation
library(googlesheets4) #to import custom dataset
library(knitr) # for displaying tables in knitted document
library(kableExtra)
library(stringr) # for data cleaning
library(MASS) # for stepwise regression

# import the libraries
source("Modules/AccomodationFunctions.R")
source("Modules/Libraries.R")
source("Modules/Tables.R")
source("Modules/Plots.R")
```

# Loading Anthropometric Data from Google Sheets
To facilitate collaboration across a distributed team and ensure the analysis reflects the most up-to-date participant data, this project retrieves anthropometric measurements directly from a centralized Google Sheet using the googlesheets4 package. This approach enables near real-time updates without the need to manually redistribute CSV files or regenerate local datasets.

The use of googlesheets4 permitted any team member with an internet connection to enter data. This R Markdown was also hosted on a computer with internet connection next to the aircraft. This allowed for rapid validation and preliminary analyses of the data added to the Google Sheets. Finally, with the Knitted R Markdown hosted in a GitHub repository, the analyses could be re-rendered with the latest data and shared with anyone, making it suitable for iterative cockpit fit evaluations or multi-phase studies.

The Google Sheet contains standardized anthropometric variables required for cockpit accommodation analysis, such as Sitting Eye Height, Buttock-Knee Length, Functional Arm Reach, and Shoulder Height. Access is authenticated securely through the user’s Google account, and the sheet can be configured with view-only or edit permissions to manage data integrity.

We also add two variables:

1. *combo leg* variable that that more accurately reflects leg reach and clearance constraints in a seated posture than any individual measure alone. 

$$
\text Combo Leg = Buttock Knee Length + Knee Height Sitting
$$
2. Body Mass Index metric to broadly categorize people based on tissue mass and height.

$$
\text{BMI} = \frac{\text{Weight (kg)}}{\text{Stature (m)}^2}
$$
```{r}
# Import survey data
df_anthros <- read_sheet("https://docs.google.com/spreadsheets/d/1ivQo0QNx1Zyjlg1WvXoPJoW9RorD8KYH4fc5BYkQhO4/edit?gid=0#gid=0")%>% as.data.frame()
rownames(df_anthros) <- df_anthros$ID


# Add combo leg
df_anthros <- df_anthros %>%
  mutate(
    'Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`,
    'Source' = "Study", #grouping variable
    'ID' = as.character(ID),
    `Weight` = round(Weight * 0.45359237,2), #convert to kg
    'BMI' = round(Weight/(Stature/1000)^2,2)
  )

# Split sexes and output csv
df_anthros_m <- df_anthros %>% filter(Sex == 'M')
write.csv(df_anthros_m, "output/anthros_m.csv", row.names = FALSE)

df_anthros_f <- df_anthros %>% filter(Sex == 'F')
write.csv(df_anthros_f, "output/anthros_f.csv", row.names = FALSE)

```
# Loading Reference Population Dataset
To evaluate accommodation within the Bell 206 cockpit, participant measurements must be compared against a broader reference population. In this project, we use the *2012 Canadian Forces Anthropometric Survey (CFAS)* as the primary population dataset. The CFAS provides a comprehensive snapshot of modern military anthropometry, including key cockpit-relevant dimensions such as sitting heights, limb lengths, and functional reaches.

The reference dataset enables both univariate and multivariate comparisons to estimate the percentage of the military population that would be expected to achieve successful accommodation under defined operational criteria. While CFAS is used in this instance due to its relevance and completeness, the framework is designed to accept any alternative anthropometric dataset that includes the necessary variables. This modularity makes the analysis portable and adaptable for use with datasets such as ANSUR II, or CAESAR.

The dataset is typically stored locally in .csv and read into the R environment as follows:

```{r}
#Load Population Dataset
pop <- read_csv("Data/CFAS_2012.csv",show_col_types = FALSE) %>% dplyr::select(-`...1`)
pop <- pop %>%
  mutate(
    Source = "CFAS 2012",
    'Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`,
    'BMI' = round(Weight/(Stature/1000)^2,2)
    )
pop_m <- pop %>% filter(Sex== "Male", Service == "RCAF")
pop_f <- pop %>% filter(Sex== "Female")

common_columns <- intersect(names(pop),names(df_anthros)) #identify the common column names in the sample and population data files
pop_m <- pop_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records
pop_f <- pop_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records

```


# Univariate Summary Tables: Raw and Percentile Comparisons
To support initial inspection of the participant dataset, this section generates univariate summary statistics for key anthropometric variables. These include both:

- Raw values (e.g., in millimetres, or kg), useful for direct dimensional interpretation and cockpit design reference, and

- Percentile rankings (%), computed by comparing each participant’s measurements against the appropriate reference population.

The percentile transformations allow for a normalized comparison of participant body dimensions relative to the broader military population and are especially useful when identifying outliers or individuals at accommodation risk due to body size extremes.


**Important Considerations for Population Comparison**

Care must be taken when selecting the appropriate population subset for percentile calculation to avoid violating statistical assumptions such as normality or representativeness. For instance:

- Sex Stratification: Male and female data should always be assessed separately due to fundamental differences in body size distributions.

- CFAS 2012 Sample Limitations: While the CFAS provides sufficient sample size to support stratified analysis of male subjects across military branches (Navy, Army, Air Force), the female sample sizes were not large enough within branches to yield statistically significant stratified comparisons. Therefore, female participant percentiles should only be assessed against the total female militaryfrom the combined entire Canadian Armed Forces (CAF).

- The output tables below provide summary statistics for each participant's measurements in both raw and percentile formats. These tables serve as a diagnostic tool to identify individuals who may fall outside accommodation envelopes for specific cockpit features.

```{r}
sample_scaled_pop <- scale_sample_based_on_population(df_anthros_m,pop_m %>% dplyr::select(-'Source',-Weight,-ID))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_m,sample_percentile)
write.csv(df_anthros_m, "output/antho_m.csv", row.names = FALSE)
write.csv(sample_percentile, "output/percentile_m.csv", row.names = FALSE)
write.csv(sample_anthro_percentile, "output/anthro_percentile_m.csv", row.names = FALSE)

anthro_summary_m <- sample_anthro_percentile 

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_m %>% dplyr::select(1:5)
block_2 <- anthro_summary_m %>% dplyr::select(6:10)
block_3 <- anthro_summary_m %>% dplyr::select(11:15)
block_4 <- anthro_summary_m %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Male Block 1: Variables 1–5")
kable(block_2, caption = "Male Block 2: Variables 6–10")
kable(block_3, caption = "Male Block 3: Variables 11–15")
kable(block_4, caption = "Male Block 4: Variables 16–20")

sample_scaled_pop <- scale_sample_based_on_population(df_anthros_f,pop_f%>% dplyr::select(-'Source',-Weight,-ID))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_f,sample_percentile)
write.csv(df_anthros_f, "output/antho_f.csv", row.names = FALSE)
write.csv(sample_percentile, "output/percentile_f.csv", row.names = FALSE)
write.csv(sample_anthro_percentile, "output/anthro_percentile_f.csv", row.names = FALSE)

anthro_summary_f <- sample_anthro_percentile

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_f %>% dplyr::select(1:5)
block_2 <- anthro_summary_f %>% dplyr::select(6:10)
block_3 <- anthro_summary_f %>% dplyr::select(11:15)
block_4 <- anthro_summary_f %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Female Block 1: Variables 1–5")
kable(block_2, caption = "Female Block 2: Variables 6–10")
kable(block_3, caption = "Female Block 3: Variables 11–15")
kable(block_4, caption = "Female Block 4: Variables 16–20")
```

# Bivariate Plot: Sitting Height vs. Combo Leg
The figure below presents a bivariate plot of *Sitting Height* against the synthetic *Combo Leg* variable for the study participants, overlaid on the broader reference population. This plot is a central tool in cockpit fit mapping as it illustrates not only the absolute dimensions of individuals, but more importantly, their *body proportions*—specifically the torso-to-limb relationship.

As described in Zehner (2001), two individuals with identical stature may have significantly different cockpit fit outcomes depending on whether they are long-torso/short-leg or short-torso/long-leg. This distinction can impact multiple aspects of cockpit accommodation, including over-the-nose vision, rudder pedal reach, and stick interference with the thigh. By plotting participants in this bivariate space, we can visually assess the range of proportional variability represented in the test sample, identify outliers, and determine whether the dataset includes edge-case anthropometries that could pose fit challenges.

This type of visualization is also useful for *selecting subjects* for physical mock-up testing or simulation studies, ensuring coverage of anthropometric edge cases that might otherwise be underrepresented if relying solely on univariate stature percentiles.
```{r}

clean_m <- df_anthros_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')
clean_f <- df_anthros_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')

data_m <- rbind(pop_m, clean_m)
# Plot
ggplot(data_m, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_m %>% as.data.frame(),
    aes(label = rownames(clean_m), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Male Participant Data vs. CFAS 2012:Male RCAF (90% CI)") +
  theme_minimal()

data_f <- rbind(pop_f, clean_f)
ggplot(data_f, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_f %>% as.data.frame(),
    aes(label = rownames(clean_f), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Female Participant Data vs. CFAS 2012:Female CAF (90% CI)") +
  theme_minimal()


f_sex <- clean_f %>%
  mutate(
    Sex = "F",
    Group = "Study"
  )

m_sex <- clean_m %>%
  mutate(
    Sex = "M",
    Group = "Study"
  )

pop_m_sex <- pop_m %>%
  mutate(
    Sex = "M",
    Group = "Male"
  )

pop_f_sex <- pop_f %>%
  mutate(
    Sex = "F",
    Group = "Female"
  )

clean_combined <- rbind(pop_f_sex,pop_m_sex,m_sex,f_sex)
study_df = rbind(m_sex,f_sex)

ggplot(clean_combined, aes(x = `Combo Leg`, y = `Sitting Height`, color = Group)) +
  # Population points
  geom_point(alpha = 0.35, size = 2) +
  # 90% confidence ellipses per Sex (bivariate normal ellipse)
  stat_ellipse(data = clean_combined %>% filter(Group %in% c("Male", "Female")),level = 0.90, linewidth = 1) +
  # Overlay study points (black crosses, sit on top)
  geom_point(data = study_df, aes(x = `Combo Leg`, y = `Sitting Height`),
             inherit.aes = FALSE, shape = 4, size = 3, stroke = 1.1) +
  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = study_df %>% as.data.frame(),
    aes(label = ID, x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1
  ) +
  labs(
    x = "Combo Leg (mm)",
    y = "Sitting Height (mm)",
    title = "Combo Leg vs Sitting Height",
    subtitle = "Population by Sex with 90% confidence ellipses; study overlay as crosses"
  ) +
  #scale_color_manual(values = c("M" = "navy", "F" = "deeppink"))+
  theme_minimal(base_size = 12)

ggsave("plots/Combo Leg vs. Sitting Height.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")



```

# Principal Component Analysis: Core Six Measures
To further explore the multivariate structure of anthropometric variability relevant to cockpit fit, this section applies Principal Component Analysis (PCA) using the six most critical cockpit-relevant body dimensions—commonly mentioned earlier.  PCA combines the variables in a way that maximizes the variance of the PC1 as evident by the highest Sums of Squares of the `loadings`, followed by the diametrically opposed PC2 and so on. Maximizing the variance in PC1 is good for dimension reduction but can result in loadings that are difficult to interpret. In the CFAS data, we see that the absolute values of the weights for PC1 are greater than 0.7 whereas the absolute values of PC2 loadings are around 0.4. This makes is difficult describe which variables are associated to PC1 or PC2.

```{r}

# Select measures of interests. Recommended 'Core Six'

pca_vars = c(
    "Sitting Height",
    "Eye Height - Sitting",
    "Acromial Height - Sitting",
    "Knee Height - Sitting",
    "Buttock-Knee Length",
    "Thumbtip Reach"
  )

# Define study vs pop data - Males

pop_pca <- pop_m
study_pca <- clean_m

pop_pca <- pop_pca %>%
  dplyr::select(pca_vars
  ) %>%
  na.omit()

study_pca <- study_pca %>%
  dplyr::select(pca_vars) %>%
  na.omit()

# Perform PCA - MALE

scaled_data <- scale(pop_pca) # Standardize the population data (mean = 0, SD = 1)

pca_data_no_rotation <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="none")

print(pca_data_no_rotation$loadings)
weights_no_rotation <- pca_data_no_rotation$weights %>% as.data.frame()

loadings_no_rot <- pca_data_no_rotation$loadings %>% as.data.frame()
loadings_no_rot <- loadings_no_rot[1:(nrow(loadings_no_rot)/2),]

ggplot(loadings_no_rot, aes(x = PC1, y = PC2))+geom_point()+
  scale_x_continuous(limits = c(-1,1)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-1,1)) +  # Define y-axis limits
  geom_vline(xintercept = 0, color = "black", linetype = "dotted") +  # Vertical line for y-axis
  geom_hline(yintercept = 0, color = "black", linetype = "dotted") +  # Horizontal line for x-axis
  theme_minimal() + # Minimal theme for cleaner appearance
    labs(
         x = "RC1",
         y = "RC2",
         title = "Loadings - No Rotation")+
  geom_text(aes(label = rownames(loadings_no_rot)), vjust = 1.5, hjust = -0.5, size = 3)   # Text labels with row 


```




When we look at the cumulative variance of Principal Component 1 and 2, we find that they account for ~85% of the variability of the underlying dataset. This is sufficient for accommodation modelling purposes.  We can discard the remaining principle components and apply a varimax rotation to the retained PC1 and PC2 loadings to improve the interpretability of the results. A varimax rotation adjusts the weights of the principle components closer to 0 or 1. The new coordinates are called *Rotated Component* scores RC1 and RC2. Note that unlike PC1, RC1 no longer accounts for the largest amount of the variability within the underlying dataset. Rather, the variance is more equally shared between RC1 and RC2 and together, still accound for 85% of the variability of the underlying dataset. 
```{r}

pca_data <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="varimax")

weights_varimax <- pca_data$weights %>% as.data.frame()
weights_varimax

loadings_varimax <- pca_data$loadings %>% as.data.frame()
loadings_varimax <- loadings_varimax[1:(nrow(loadings_varimax)/2),]
loadings_varimax


ggplot(loadings_varimax, aes(x = RC1, y = RC2))+geom_point()+
  scale_x_continuous(limits = c(-1,1)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-1,1)) +  # Define y-axis limits
  geom_vline(xintercept = 0, color = "black", linetype = "dotted") +  # Vertical line for y-axis
  geom_hline(yintercept = 0, color = "black", linetype = "dotted") +  # Horizontal line for x-axis
  theme_minimal() + # Minimal theme for cleaner appearance
    labs(
         x = "RC1",
         y = "RC2",
         title = "Loadings - Varimax")+
  geom_text(aes(label = rownames(loadings_varimax)), vjust = 1.5, hjust = -0.5, size = 3)   # Text labels with row 



```

These new rotated dimensions capture the major axes of cockpit interaction. RC1 loads most highly on torso measurements whereas R2 loads on limb measurements.

Each participant's anthropometric profile is  projected into this rotated PC space, allowing us to plot them relative to the broader population distribution. This enables:

- Identification of outliers body types (e.g., extreme limb-to-torso proportions),

- Assessment of whether the participant sample adequately spans a target accommodation level (ellipse boundary), and

- Support for subject selection in physical fit validation, ensuring inclusion of worst-case accommodation points.



```{r}

study_scaled <- ScaleToPopulation(study_pca,pop_pca) %>% as.matrix() # scale study data per population
study_scores <- ScaleToPC(study_scaled,pca_data$weights) # calculate PC scores for study data

ellipse_frame <- AccommodationEllipse(90) # set accommodation ellipse level

pca_plot <- ggplot() +
   geom_point(data = pca_data$scores %>% as.data.frame(), aes(x = RC1, y = RC2)) +
   geom_point(data = study_scores %>% as.data.frame(), aes(x = RC1, y = RC2), shape = 21,color="blue", size = 4) +
   geom_path(data = ellipse_frame, aes(x=ellipse_frame[,1], y=ellipse_frame[,2]), color='red')+
  geom_label(data = study_scores %>% as.data.frame(), aes(label = rownames(study_scores),x = RC1,y=RC2), color = "blue", vjust = -0.5, hjust = 1)+
  
  scale_x_continuous(limits = c(-3, 3)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-3, 3))+   # Define y-axis limits
     labs(
         x = "RC1",
         y = "RC2",
         title = "PC Scores(Varimax): Study vs. Population (Male)",
         subtitle = "Black: CFAS 2012, Red: 90% Accommodation Boundary"
     )+
    theme_minimal() # Minimal theme for cleaner appearance
      
print("Male")
print(pca_data$loadings)
print(pca_plot)

# Define study vs pop data - Feamle

pop_pca <- pop_f
study_pca <- clean_f

pop_pca <- pop_pca %>%
  dplyr::select(pca_vars
  ) %>%
  na.omit()

study_pca <- study_pca %>%
  dplyr::select(pca_vars) %>%
  na.omit()

# Perform PCA - Female

scaled_data <- scale(pop_pca) # Standardize the population data (mean = 0, SD = 1)

pca_data_none <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="none")
pca_data <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="varimax")

study_scaled <- ScaleToPopulation(study_pca,pop_pca) %>% as.matrix() # scale study data per population
study_scores <- ScaleToPC(study_scaled,pca_data$weights) # calculate PC scores for study data

ellipse_frame <- AccommodationEllipse(90) # set accommodation ellipse level

pca_plot <- ggplot() +
   geom_point(data = pca_data$scores %>% as.data.frame(), aes(x = RC1, y = RC2)) +
   geom_point(data = study_scores %>% as.data.frame(), aes(x = RC1, y = RC2), shape = 21,color="blue", size = 4) +
   geom_path(data = ellipse_frame, aes(x=ellipse_frame[,1], y=ellipse_frame[,2]), color='red')+
  geom_label(data = study_scores %>% as.data.frame(), aes(label = rownames(study_scores),x = RC1,y=RC2), color = "blue", vjust = -0.5, hjust = 1)+
  
  scale_x_continuous(limits = c(-3, 3)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-3, 3))+   # Define y-axis limits
     labs(
         x = "RC1",
         y = "RC2",
         title = "PC Scores(Varimax): Study vs. Population (Female)",
         subtitle = "Black: CFAS 2012, Red: 90% Accommodation Boundary"
     )+
    theme_minimal() # Minimal theme for cleaner appearance
print("Female")      
print(pca_data$loadings)
print(pca_plot)

```


```{r}

#load all the participant performacne data from GoogleSheets

df_onv <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-head_clear_pass_fail,-head_clear_mm)

df_onv_737 <- read_sheet("https://docs.google.com/spreadsheets/d/1q4_3hE1rEuWwfZEBP-a2KvRsFJBqM5GBcgHjXmiWA-4/edit?gid=1101471552#gid=1101471552") %>% as.data.frame()

df_head_clear <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-onv_deg)

df_shin <- read_sheet("https://docs.google.com/spreadsheets/d/1a-abUwfAivR8DNFgPDc2Ht7mFQ0ebO0C9q-vG3LxbbY/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1SicW4frwWsSooKwXwwccX8j4VLic3yP3nzLgLFoz5Dg/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_range_of_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1VTS-rYKKtNIpy1KneRvKB3fzVJ25YvdVLo3l9Cayq9M/edit?gid=0#gid=0") %>% as.data.frame()
 
df_rudder <- read_sheet("https://docs.google.com/spreadsheets/d/1w8L0ETVMvDVrFIsYAB5N1idFtRWpR8AfZq3mh6kZ6Fc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_hand_reach <- read_sheet("https://docs.google.com/spreadsheets/d/1MezpHsf-7rbU6M6C6czHL7ZJDAOgsHX63HWkZWBLItc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_controls <- read_sheet("https://docs.google.com/spreadsheets/d/1QnLAoSWwkXrCxc5orFyGn6PkcvkZnylNm4Erdpp2NsY/edit?gid=0#gid=0") %>% as.data.frame()

```

# Head Clearance

A linear model was used to examine how body dimensions relate to overhead clearance in the Bell 206 cockpit. As expected, the analysis found that sitting height is a strong predictor of available head clearance, with taller individuals having less space overhead. The relationship is intuitive with head clearance reducing proportionally with sitting height. The model explains nearly all of the variation in head clearance across participants. We calculate the theoretical maximum sitting height with zero clearance. We also plot predicted vs. actual head clearance against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

$$
\text{Head Clearance} = 1043.36 - 1.03\cdot \text{Sitting Height}
$$
When we account for a 38 mm thick helmet and predict the accommodation level of the target female and male populations within the 2012 CFAS, we find that 99% of females and 91% of males will have sufficient head clearance in the Bell 206. Assuming zero clearance between a helmet and the overhead panel is acceptable, the maximum sitting height is 
$$
\text{Sitting Height} = \frac{\text{38 mm}-{1043.36}}{\text-1.03}
$$
$$
\text{Max Sitting Height} = \text{976 mm}
$$


```{r}

#Join anthros

df <- df_head_clear %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Sitting Height`, df$head_clear_mm, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Sitting Height`, y = head_clear_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Head Clearance vs. Sitting Height",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Sitting Height (mm)",
    y = "Head Clearance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Sitting Height`, y = head_clear_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
  scale_y_reverse()+
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(head_clear_mm ~ `Sitting Height`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$head_clear_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$head_clear_mm_predicted,
  actual = df$head_clear_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Head Clearance = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Head Clearance",
    subtitle = subtitle_text,
    x = "Predicted Head Clearance (mm)",
    y = "Actual Head Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  scale_x_continuous(limits = c(0,150)) +  # Define x-axis limit
  geom_hline(yintercept = 43, linetype = "dashed", color = "red") + # helmet clearance 35 mm + 8 mm
  annotate("text", x = Inf, y = 45, label = "Dissaccommodated (helmet)", hjust = 1.1, vjust = 2.5, color = "red")+
  theme_minimal()

ggsave("plots/Predicted vs. Actual Head Clearance.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new <- pop
df_new$head_clear_predicted <- predict(step_model, newdata = pop)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(head_clear_predicted < 43, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>% drop_na %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Head Clearance (Helmet Thickness 35 mm + 8 mm)")


```

# Over the Nose Vision

A linear model was developed to explore how body dimensions influence over-the-nose vision in the Bell 206. The analysis found that eye height, sitting is strongly associated with ONV angle — individuals with taller seated eye heights tend to have better downward visibility. While waist depth was included in the model to account for the horizontal offset of the shoulder from the seat back, it did not show a strong statistical effect. Overall, the model explains a high proportion of the variation in ONV among participants. Full model details and statistics are provided in the code and output below. We also plot predicted vs. actual ONV against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

```{r}

#Join anthros

df <- df_onv %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Eye Height - Sitting`, df$onv_deg, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Eye Height - Sitting`, y = onv_deg)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "External Vision vs. Eye Height (Sitting)",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Eye Height - Sitting (mm)",
    y = "External Vision Over the Nose (degrees)"
  ) +
  scale_y_reverse()+
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Eye Height - Sitting`, y = onv_deg),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(onv_deg ~ `Eye Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Add predicted values to the original dataframe
df$onv_deg_predicted <- predict(step_model)

# Generate predicted values and confidence intervals
df$onv_deg_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$onv_deg_predicted,
  actual = df$onv_deg,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "ONV = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Over-the-Nose Vision (ONV)",
    subtitle = subtitle_text,
    x = "Predicted ONV (degrees)",
    y = "Actual ONV (degrees)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  scale_y_continuous(limits = c(-25,-5)) +
  scale_x_continuous(limits = c(-24,-15)) +
  geom_hline(yintercept = -12, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = -12, label = "Dissaccommodated", hjust = 1.1, vjust = -0.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Over the Nose Vision.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new$ONV_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(ONV_predicted > -12, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Over the Nose Vision (-12 deg)")
```

# Shin Clearance

Shin clearance was assessed using the minimum measured distance between the participant’s shins and the instrument panel across all pedal positions. Following the methodology adapted from Kennedy (2001) a regression analysis was performed to evaluate the predictive value of lower limb anthropometric dimensions. The Bell 206 instrument panel only extends over the inner-most leg (i.e., the left shin when seated in the right pilot seat)

Initial Pearson correlation analysis showed a strong negative correlation between Combo Leg Length and shin clearance (r = -0.95, *p* < 0.001), indicating that individuals with longer lower limbs are more likely to experience reduced clearance.

A stepwise linear regression confirmed that Combo Leg Length alone was the most predictive variable. The final model explained over 90% of the variance in shin clearance (*R²* = 0.91), with each additional millimetre of Combo Leg associated with a 0.39 mm decrease in clearance. Other candidate predictors, including Buttock-Knee Length and rudder pedal displacement, did not significantly improve model performance and were removed during model selection. We also plot predicted vs. actual clearance against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

We also found that most participants experienced minimum clearance to their left shin with the right pedal depressed, while some experience minimum clearance when pedals neutral. Furthermost, it is believed that foot length may be a contributing factor as this effects the position of the anckle joint. This result supports the use of Combo Leg as a proxy variable when assessing lower-limb accommodation in static cockpit configurations such as the Bell 206. 

```{r}

# #Join anthros

df <- df_shin %>%
  mutate(
    ID = as.numeric(ID),
    min_clearance = pmin(neutral_clearance_mm,
                         full_left_active_mm, 
                         full_left_passive_mm, 
                         full_right_active_mm, 
                         full_right_passive_mm, 
                         na.rm = TRUE
                         )
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Combo Leg`, df$min_clearance, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Combo Leg`, y = min_clearance)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Shin Clearance vs. Combo Leg",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Combo Leg (Buttock Knee Length + Knee Height - Sitting) (mm)",
    y = "Minimum Shin Clearance"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Combo Leg`, y = min_clearance),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()



# Fit linear model

model <- lm(min_clearance ~ `Buttock-Knee Length` +
              `Combo Leg`+ `Knee Height - Sitting` + rudder_mm, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)


# Generate predicted values and confidence intervals
df$min_clearance_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$min_clearance_predicted,
  actual = df$min_clearance,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Shin Clearance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Shin Clearance",
    subtitle = subtitle_text,
    x = "Predicted Shin Clearance (mm)",
    y = "Actual Shin Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  scale_y_continuous(limits = c(0,200)) +
  geom_hline(yintercept = 38, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = 38, label = "Dissaccommodated", hjust = 1.1, vjust = 1.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Shin Clearance.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")

df_new$shin_clear_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(shin_clear_predicted < 38, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Shin Clearance (38 mm)")
```
# Cylic Clearance to Abdomen

A strong negative correlation was observed between Waist Depth and the aft clearance margin to the cyclic (r = -0.96, p < 0.001), suggesting that as waist depth increases, the available clearance behind the cyclic decreases.

A linear regression model was created to predict aft clearance using three body measurements: Stature, Thigh Clearance, Biacromial Breadth, Weight, and BMI. Through model selection, only BMI and Biacromial Breadth were identified as the most suitable predictors. The other variables were found to have little added value and were removed. We also plot predicted vs. actual clearance against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

The model explained almost all the variance in clearance (Adjusted R² = 0.974) suggesting that body size and fat are a strong predictor of cyclic-to-abdomen clearance.

The results highlight that bulkier body types (higher BMI, wider torsos) will lead to reduced clearance, which could have implications for cockpit fit and safety.

```{r}

# #Join anthros

df <- df_motion %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$aft_margin_body_mm, df$`Waist Depth`, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Waist Depth`, y = aft_margin_body_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Cyclic Clearance to Abdomen vs. Waist Depth",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Waist Depth (mm)",
    y = "Cyclic / Abdomen Clearnace (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Waist Depth`, y = aft_margin_body_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(aft_margin_body_mm ~ Stature + `Thigh Clearance` + `Biacromial Breadth` + 
          Weight + BMI, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted 

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Cyclic Clearance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Cyclic Clearance",
    subtitle = subtitle_text,
    x = "Predicted Cyclic Abdomen Clearance (mm)",
    y = "Actual Cyclic Abdomen Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  geom_hline(yintercept = 38, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = 38, label = "Dissaccommodated", hjust = 1.1, vjust = 1.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Cyclic Abdomen Clearance.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")

# Predicted values for CFAS populations are not possible because CFAS did not report on Waist Depth.

df_new$cyclic_clear_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(cyclic_clear_predicted < 38, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Cyclic to Abdomen Clearance (38 mm)")

```

# Control Motion

A multivariate linear regression was conducted to explore which anthropometric factors influence the maximum forward position a participant can achieve on the cyclic control while seated in a Zone 1 posture (i.e., upright, no leaning). In this model, 100% represents full forward cyclic travel. We also plot predicted vs. actual performance against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

```{r}

#Join anthros

# Extract full forward and aft values from the control data
cyclic_limits <- df_range_of_motion %>%
  filter(adjustment == "cyclic_fwd") %>%
  dplyr::select(min, max) %>%
  slice(1)  # In case there's more than one row

df <- df_motion %>%
  mutate(
    ID = as.numeric(ID),
    cyclic_pct_fwd = ((cyclic_limits$max-fwd_deg)/(cyclic_limits$max-cyclic_limits$min))*100
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Thumbtip Reach`, df$cyclic_pct_fwd, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = cyclic_pct_fwd)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Cyclic Control Motion (% fwd) vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Cyclic Control Motion (% fwd)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = cyclic_pct_fwd),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(cyclic_pct_fwd ~ `Thumbtip Reach` + 
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$cyclic_pct_fwd_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$cyclic_pct_fwd_predicted,
  actual = df$cyclic_pct_fwd,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "fwd_deg = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Zone 1 Cyclic Fwd Reach (%)",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Fwd Cyclic (%)",
    y = "Actual Zone 1 Fwd Cyclic (%)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  geom_hline(yintercept = 60, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = 60, label = "Disccommodated", hjust = 1.1, vjust = 1.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Zone 1 Cyclic Fwd Reach.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new$cyclic_zone1_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(cyclic_zone1_predicted < 60, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Cyclic Control Motion - Zone 1 (60% fwd)")

```

# Reach to Rudder Pedals

Rudder pedal position is a critical component of lower-body accommodation in cockpit fit mapping. The ability to achieve full rudder deflection—particularly with toe brake actuation—is essential for safe ground handling and coordinated flight. Following Zehner’s (2001) methodology, this section evaluates participants’ ability to meet the functional requirement for full rudder pedal reach with the seat various positions.

The composite `Combo Leg` variable is reported. The rudder pedals were adjusted to the most forward position that the participant could still achieve full rudder deflection and brake application. Negative values represent a missed reach. We also plot predicted vs. actual performance against an arbitrary functional requirement criterion. Finally, we use the model to predict the accommodation level of males and female target populations.

```{r}

# #Join anthros

# Extract full forward and aft values from the control data
rudder_limits <- df_range_of_motion %>%
  filter(adjustment == "rudder") %>%
  dplyr::select(min, max) %>%
  slice(1)  # In case there's more than one row

df <- df_rudder %>%
  mutate(
    ID = as.numeric(ID),
    rudder_pct_fwd = (rudder_mm/(rudder_limits$max-rudder_limits$min))*100
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")

cor_test_result <- cor.test(df$`Combo Leg`, df$rudder_mm, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Combo Leg`, y = rudder_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Rudder Carriage Position vs. Combo Leg",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Combo Leg (Buttock Knee Length + Knee Height - Sitting) (mm)",
    y = "Maximum Fwd Rudder Carriage Position (mm)"
  ) +
  scale_x_continuous(limits = c(1090,1125)) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Combo Leg`, y = rudder_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(rudder_mm ~  `Combo Leg`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$rudder_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$rudder_mm_predicted,
  actual = df$rudder_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Rudder Position Forward = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Maximum Rudder Position",
    subtitle = subtitle_text,
    x = "Predicted Maximum Forward Rudder Carriage Position (mm)",
    y = "Actual Maximum Forward Rudder Carriage Position (mm)"
  ) +
  scale_y_continuous(limits = c(0,150)) +
  scale_x_continuous(limits = c(0,150)) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()

ggsave("plots/Predicted vs. Actual Reach to Rudder Pedals.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new$rudder_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(rudder_predicted < 0, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Reach to Rudder Pedals")



```

# Reach to Controls

## Zone 1 - LOW ROTOR RPM Push Button Annunciator

The analysis investigated how well participants could reach the LOW ROTOR RPM push button without leaning (Zone 1 posture). A negative correlation was found between thumbtip reach and the miss distance—how far short the participant’s reach fell. Specifically, individuals with shorter thumbtip reach tended to have larger miss distances. The correlation was statistically significant (r = -0.80, p = 0.016), indicating a strong inverse relationship.

A linear regression model confirmed that thumbtip reach was a significant predictor of reach success. For every additional millimetre of thumbtip reach, the miss distance decreased by approximately 0.32 mm. This single-variable model explained about 65% of the variation in reach performance (R² = 0.65), and adding other variables (such as acromial height) did not improve the model. The control is outside the Zone 1 reach envelope for all male and females.


```{r}

#Join anthros

controls <- c(
  "low_rpm_mm",
  "ctrl_boost_mm"
)


df_reach_joined <- df_hand_reach %>%
  mutate(
    ID = as.numeric(ID)
    ) %>%
  pivot_longer(cols = controls, names_to = "control", values_to = "x-to") %>%
  left_join(df_controls, by = "control") %>% 
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID") %>%
    mutate(
      miss_mm = case_when(
        control_type == "thumb" ~ `x-to` - `left_x_to_thumb`,
        control_type == "finger" ~ `x-to` - `left_x_to_finger`,
        TRUE ~ NA_real_  # fallback in case of unexpected control_type
      ),
      equiv_thumbtip_reach = `x-to` + miss_mm
    )

# Account for depression activation of "finger" controls

df_reach_joined <- df_reach_joined %>%
  mutate(
    miss_mm = case_when(
      control_type == "finger" ~ miss_mm + 3, # button depression
      TRUE ~ miss_mm  # keep original value for all other types
    )
  )
```

```{r}

# Zone 1 - RPM

df <- df_reach_joined %>% filter(
  control == "low_rpm_mm",
  zone == 1
)

cor_test_result <- cor.test(df$miss_mm, df$`Thumbtip Reach`, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = miss_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Miss to Low RPM Button vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Zone 1 Miss Distance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = miss_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(miss_mm ~ `Thumbtip Reach` +
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$miss_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$miss_mm_predicted,
  actual = df$miss_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Miss Distance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Zone 1 Miss to LOW ROTOR Push Button",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Miss to LOW ROTOR Push Button (mm)",
    y = "Actual Zone 1 Miss to LOW ROTOR Push Button(mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = -12, label = "Dissaccommodated", hjust = 1.1, vjust = -2.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Zone 1 LOW ROTOR.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new$rpm_zone1_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(rpm_zone1_predicted > 0, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Zone 1 Reach to Low Rotor RPM")

```

## Zone 1 - Control Boost Toggle Switch

The analysis assessed whether body dimensions could predict participants’ ability to reach the Control Boost toggle switch without leaning (Zone 1 posture). The Pearson correlation between thumbtip reach and miss distance was moderately strong (r = -0.66), suggesting that longer thumbtip reach may be associated with better reach performance. However, this relationship did not reach statistical significance (p = 0.074), possibly due to the small sample size.

A linear regression model including thumbtip reach and acromial height accounted for about 60% of the variation in miss distance (R² = 0.60). Of the two predictors, thumbtip reach showed a borderline significant contribution (p = 0.058), with each additional millimetre of reach associated with a 0.85 mm reduction in miss distance. Acromial height was not a significant predictor.

These findings suggest that thumbtip reach may still be a relevant measure for reach performance, though the relationship in this case is weaker and less conclusive compared to other controls. Further data may help clarify this relationship.

The control is outside the Zone 1 reach envelope for all male and females

```{r}
# Zone 1 - Control Boost

df <- df_reach_joined %>% filter(
  control == "ctrl_boost_mm",
  zone == 1
)

cor_test_result <- cor.test(df$miss_mm, df$`Thumbtip Reach`, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = miss_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Miss to Control Boost vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Zone 1 Miss Distance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = miss_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(miss_mm ~ `Thumbtip Reach` +
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$miss_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$miss_mm_predicted,
  actual = df$miss_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Miss Distance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  labs(
    title = "Predicted vs Actual Zone 1 Miss to Control Boost Toggle Switch",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Miss to Control Boost Toggle Switch (mm)",
    y = "Actual Zone 1 Miss to Control Boost Toggle Switch"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()

ggsave("plots/Predicted vs. Actual Zone 1 CONTROL BOOST.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


df_new$ctrl_boost_predicted <- predict(step_model, newdata = df_new)

df_summary <- df_new %>%
  mutate(predicted_class = ifelse(ctrl_boost_predicted > 0, "Dissaccommodated", "Accommodated")) %>%
  group_by(Sex, predicted_class) %>%
  count() %>%
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Zone 1 Reach to Control Boost Toggle Switch")

# write CFAS with predicted performance
write.csv(df_new, "output/CFAS_predicted.csv", row.names = FALSE)


```

# Boeing 737 Over the Nose Vision

We also took the opportunity to measure the over the nose vision of the Beoing 737 pilot seat which has horizontal and vertical adjustments. Notably, both vertical and horizontal adjustments rotate the seat about a pivoting arm. Therefore affect vertical and horizontal adjustments change the x and y coordinates of the seat reference point. For simplicity, ONV were recorded at seat full up/aft, down/aft, and down/fwd. The seat also includes a back rest recline adjustment and ONV measurements were taken in the most upright and most recline tilt settings. The full up/fwd position was not recorded because it was falsely thought to be inaccessible due to the overall difficulty in adjusting the seat position.

```{r}

df_seat_positions <- read_sheet("https://docs.google.com/spreadsheets/d/1ZP8djxCW8M4S3qmLSWnqe8YVQoUlXagu-mWTaeU3V0Q/edit?gid=0#gid=0") %>% as.data.frame()

#Join anthros

df <- df_onv_737 %>%
  mutate(
    ID = as.numeric(ID),
    seat_up_mm = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ 0,
      seat_up_step == 0 & seat_fwd_step == 1 ~ df_seat_positions$y_mm[df_seat_positions$pos == "down_fwd"] - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"],
      seat_up_step == 1 & seat_fwd_step == 0 ~ df_seat_positions$y_mm[df_seat_positions$pos == "up_aft"] - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"],
      seat_up_step == 1 & seat_fwd_step == 1 ~ df_seat_positions$y_mm[df_seat_positions$pos == "up_fwd"]  - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"]
    ),
    seat_fwd_mm = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ 0,
      seat_up_step == 0 & seat_fwd_step == 1 ~  df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "down_fwd"],
      seat_up_step == 1 & seat_fwd_step == 0 ~ df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "up_aft"],
      seat_up_step == 1 & seat_fwd_step == 1 ~ df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "up_fwd"]
    ),
    seat_pos = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ "down_aft",
      seat_up_step == 0 & seat_fwd_step == 1 ~ "down_fwd",
      seat_up_step == 1 & seat_fwd_step == 0 ~ "up_aft",
      seat_up_step == 1 & seat_fwd_step == 1 ~ "up_fwd",
    )
  ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")

df_UpAft <- df %>%
  filter(
    seat_up_step == 1,
    seat_fwd_step == 0,
    recline_up == 1
  ) 

cor_test_result <- cor.test(df_UpAft$`Eye Height - Sitting`, df_UpAft$onv_deg, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df_UpAft, aes(x = `Eye Height - Sitting`, y = onv_deg)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Over the Nose Vision vs. Eye Height Sitting (Up, Aft)",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Eye Height - Sitting (mm)",
    y = "External Vision Over the Nose (degrees)"
  ) +
  geom_text(
    data = df_UpAft %>% as.data.frame(),
    aes(label = ID, x = `Eye Height - Sitting`, y = onv_deg),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  geom_hline(yintercept = 13, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = 13, label = "Accommodated", hjust = 1.1, vjust = -0.5, color = "blue")+
  annotate("text", x = Inf, y = 13, label = "Disccommodated", hjust = 1.1, vjust = 1.5, color = "red")+
  
  theme_minimal()

# Fit linear model

df <- df %>%
  filter(
    recline_up == 1
  )

model <- lm(onv_deg ~ `Eye Height - Sitting` + 
              seat_up_step + 
              seat_fwd_step, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Add predicted values to the original dataframe
df$onv_deg_predicted <- predict(step_model)

# Generate predicted values and confidence intervals
df$onv_deg_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$onv_deg_predicted,
  actual = df$onv_deg,
  ID = df$ID,
  seat_pos = df$seat_pos
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "ONV = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual, color = seat_pos)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Over-the-Nose Vision (ONV)",
    subtitle = subtitle_text,
    x = "Predicted ONV (degrees)",
    y = "Actual ONV (degrees)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3,
    show.legend = FALSE
  ) +
  theme(
  plot.margin = margin(t = 10, r = 80, b = 10, l = 10)
) +
  geom_hline(yintercept = 12, linetype = "dashed", color = "red") + # ONV requirement (arbitrary -12 degree requirement)+
  annotate("text", x = Inf, y = 12, label = "Accommodated", hjust = 1.1, vjust = -0.5, color = "blue")+
  annotate("text", x = Inf, y = 12, label = "Disccommodated", hjust = 1.1, vjust = 1.5, color = "red")+
  
  theme_minimal()

ggsave("plots/Predicted vs. Actual Beoing 737 ONV.png", plot = last_plot(), width = 9.5, height = 5, dpi = 200,bg="white")


subtitle_text

# Create 4 configurations per participant
df_expanded <- bind_rows(
  df_new %>% mutate(seat_up_step = 0, seat_fwd_step = 0, seat_config = "down_aft"),
  df_new %>% mutate(seat_up_step = 1, seat_fwd_step = 1, seat_config = "up_fwd"), # no data was collected from this seat setting to inform the model
  df_new %>% mutate(seat_up_step = 1, seat_fwd_step = 0, seat_config = "up_aft"),
  df_new %>% mutate(seat_up_step = 0, seat_fwd_step = 1, seat_config = "down_fwd")
)

df_expanded$y_predicted <- predict(step_model, newdata = df_expanded)

df_summary <- df_expanded %>%
  group_by(ID, Sex) %>%  
  summarise(
    any_accommodated = any(y_predicted > 12), # functional requirement
    .groups = "drop"
  ) %>%
  mutate(
    predicted_class = ifelse(any_accommodated, "Accommodated", "Dissaccommodated")
  ) %>% 
  group_by(Sex, predicted_class) %>%
  count() %>% 
  group_by(Sex) %>%
  mutate(percentage = round(100 * n / sum(n), 1)) %>%
  ungroup()

kable(df_summary, caption = "Accommodation of Boeing 737 ONV (13 degrees)")

```


```{r}
sessionInfo()
```
