---
title: "Bell 206 Anthro Accommodation"
author: "Patrick Bickerton"
date: "2025-05-31"
output: 
  prettydoc::html_pretty:
    toc: true
    toc_depth: 2
    theme: hpstr
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The design and evaluation of crewstations, such as helicopter cockpits, must address the challenge of accommodating a diverse range of body sizes. In military aviation, this issue has traditionally been managed by setting anthropometric entry requirements that narrow the pool of eligible pilots. However, evolving policy and operational demands—such as efforts to diversify aircrew populations—have renewed focus on optimizing cockpit designs for broader anthropometric inclusion. This R Markdown document presents a cockpit accommodation mapping analysis for the Bell 206 Helicopter, leveraging the methodology presented by Zehner (2001). The aim is to provide both technical documentation and an instructional resource that integrates anthropometric data, analytical code, and visualization.

# Methodological Overview

The methodological framework used for this study mirrors the structured approach defined by Zehner (2001), comprising the following steps:

* Defining the User Population: We selected a representative anthropometric sample from the available dataset, filtered to reflect the demographic and physical characteristics of prospective rotary-wing pilots. This includes stature, sitting height, and buttock-knee length, which are known to influence cockpit accommodation.

* Identifying Operational Requirements: Functional reach, visibility (especially over-the-nose vision), and control actuation were defined as essential operational criteria for the Bell 206. These would normally be informed by pilot interviews, historical ergonomics literature, and observed control configurations in the aircraft. However, for the present effort, these were arbitrarily defined by the test team to prioritize the training opportunity.

* Cockpit Mapping: Anthropometric variables were mapped against cockpit features using regression modeling. Accommodation success was evaluated by comparing predicted values—such as eye height or functional reach—against thresholds necessary to operate the helicopter safely.

* Predicting Population-Level Accommodation: Using population percentile data and bivariate regression models, we estimated the percentage of the population likely to be accommodated within the existing cockpit geometry.

Each of these phases is documented in this R Markdown file, with corresponding code, figures, and summaries provided inline.

# Anthropometric Dataset Description
The analysis draws from a curated subset of anthropometric data representative of the potential user population. Data selection emphasized key dimensions affecting cockpit fit, including the "core six":

* Sitting Height, (for head clearance to overhead control panel),

* Eye Height, Sitting (for vision clearance),

* Acromial Height, Sitting (for control alignment and clearance assessments),

* Buttock-Knee Length (for legroom and pedal reach),

* Knee Height, Sitting (for legroom and pedal reach),

* Thumbtip Reach (for lateral and forward reach envelope),

Additional anthropometric measurements were taken for exploratory purposes

All data cleaning and filtering steps are documented in the accompanying code chunks. Where applicable, outlier handling and dimension normalization were performed to align with assumptions of multivariate modeling.

# Libraries and Custom Functions

Before proceeding with the analysis, we begin by loading the necessary R packages and sourcing a set of custom functions used across multiple anthropometric accommodation projects. These functions are modular and have been developed to streamline common tasks such as data cleaning, cockpit geometry transformation, percentile calculation, and visualization.

The following code chunk performs two key functions:

1. Load Required Libraries: Core packages such as tidyverse for data manipulation and plotting, readr and googlesheets 4 for file input, and ggplot2 for visualizations are loaded.

2. Source Custom Functions: Custom R scripts are sourced to make reusable functions available in the current environment. These scripts contain purpose-built code for cockpit fit assessments—such as functions to compute univariate percentiles of the participants compared to a population data set.

This initialization step ensures a consistent analytical environment and supports reproducibility across cockpit accommodation studies.

```{r}
# import the libraries
library(tidyr)
library(ggplot2)
library(readr)
library(dplyr)
library(psych) #for principle component analysis with VARIMAX rotation
library(googlesheets4) #to import custom dataset
library(knitr) # for displaying tables in knitted document
library(kableExtra)
library(stringr) # for data cleaning
library(MASS) # for stepwise regression

# import the libraries
source("Modules/AccomodationFunctions.R")
source("Modules/Libraries.R")
source("Modules/Tables.R")
```

# Loading Anthropometric Data from Google Sheets
To facilitate collaboration across a distributed team and ensure the analysis reflects the most up-to-date participant data, this project retrieves anthropometric measurements directly from a centralized Google Sheet using the googlesheets4 package. This approach enables near real-time updates without the need to manually redistribute CSV files or regenerate local datasets.

The use of googlesheets4 supports version control and reproducibility, particularly when this R Markdown file is deployed or shared through GitHub. When hosted in a GitHub repository, the analysis can be automatically re-rendered with the latest data, making it suitable for iterative cockpit fit evaluations or multi-phase studies.

The Google Sheet contains standardized anthropometric variables required for cockpit accommodation analysis, such as Sitting Eye Height, Buttock-Knee Length, Functional Arm Reach, and Shoulder Height. Access is authenticated securely through the user’s Google account, and the sheet can be configured with view-only or edit permissions to manage data integrity.

```{r}
# Import survey data
df_anthros <- read_sheet("https://docs.google.com/spreadsheets/d/1ivDEK3W4lSWOvc1rr_CDwM9fo-UZnU5sg26lxeQjKNU/edit?gid=0#gid=0")%>% as.data.frame()
rownames(df_anthros) <- df_anthros$ID


# Add combo leg
df_anthros <- df_anthros %>%
  mutate(
    'Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`,
    'Source' = "Study",
    'ID' = as.character(ID),
    `Weight` = round(Weight * 0.45359237,2)
  )

# Split sexes and output csv
df_anthros_m <- df_anthros %>% filter(Sex == 'M')
write.csv(df_anthros_m, "output/anthros_m.csv", row.names = FALSE)

df_anthros_f <- df_anthros %>% filter(Sex == 'F')
write.csv(df_anthros_f, "output/anthros_f.csv", row.names = FALSE)

```
# Loading Reference Population Dataset
To evaluate accommodation within the Bell 206 cockpit, participant measurements must be compared against a broader reference population. In this project, we use the *2012 Canadian Forces Anthropometric Survey (CFAS)* as the primary population dataset. The CFAS provides a comprehensive and high-resolution snapshot of modern military anthropometry, including key cockpit-relevant dimensions such as stature, sitting height, limb lengths, and functional reaches.

The reference dataset enables both univariate and multivariate comparisons to estimate the percentage of the military population that would be expected to achieve successful accommodation under defined operational criteria. While CFAS is used in this instance due to its relevance and completeness, the framework is designed to accept any alternative anthropometric dataset that includes the necessary variables. This modularity makes the analysis portable and adaptable for use with datasets such as ANSUR II, or CAESAR.

We also add the composite *combo leg* variable that sums buttock-knee length, knee height - sitting, that more accurately reflects leg reach and clearance constraints in a seated posture than any individual measure alone.

The dataset is typically stored locally in .csv and read into the R environment as follows:

```{r}
#Load Population Dataset
pop <- read_csv("Data/CFAS_2012.csv",show_col_types = FALSE) %>% dplyr::select(-`ID`,-`...1`)
pop <- pop %>%
  mutate(Source = "CFAS 2012")%>%
  mutate('Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`)
pop_m <- pop %>% filter(Sex== "Male", Service == "RCAF")
pop_f <- pop %>% filter(Sex== "Female")

common_columns <- intersect(names(pop),names(df_anthros)) #identify the common column names in the sample and population data files
pop_m <- pop_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records
pop_f <- pop_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records

```


# Univariate Summary Tables: Raw and Percentile Comparisons
To support initial inspection of the participant dataset, this section generates univariate summary statistics for key anthropometric variables. These include both:

- Raw values (e.g., in millimetres), useful for direct dimensional interpretation and cockpit design reference, and

- Percentile rankings (%), computed by comparing each participant’s measurements against the appropriate reference population.

The percentile transformations allow for a normalized comparison of participant body dimensions relative to the broader military population and are especially useful when identifying outliers or individuals at accommodation risk due to body size extremes.


**Important Considerations for Population Comparison**

Care must be taken when selecting the appropriate population subset for percentile calculation to avoid violating statistical assumptions such as normality or representativeness. For instance:

- Sex Stratification: Male and female data should always be assessed separately due to fundamental differences in body size distributions.

- CFAS 2012 Sample Limitations: While the 2012 Canadian Forces Anthropometric Survey (CFAS) provides sufficient sample size to support stratified analysis of male subjects across military branches (Navy, Army, Air Force), the female sample sizes were not large enough within branches to yield statistically significant stratified comparisons. Therefore, female participant percentiles should only be assessed against the total female military population from the combined CFAS dataset.

- The output tables below provide summary statistics for each participant's measurements in both raw and percentile formats. These tables serve as a diagnostic tool to identify individuals who may fall outside accommodation envelopes for specific cockpit features.

```{r}
sample_scaled_pop <- scale_sample_based_on_population(df_anthros_m,pop_m %>% dplyr::select(-'Source',-Weight))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_m,sample_percentile)
write.csv(sample_anthro_percentile, "output/anthro_percentile_m.csv", row.names = FALSE)

anthro_summary_m <- sample_anthro_percentile 

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_m %>% dplyr::select(1:5)
block_2 <- anthro_summary_m %>% dplyr::select(6:10)
block_3 <- anthro_summary_m %>% dplyr::select(11:15)
block_4 <- anthro_summary_m %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Male Block 1: Variables 1–5")
kable(block_2, caption = "Male Block 2: Variables 6–10")
kable(block_3, caption = "Male Block 3: Variables 11–15")
kable(block_4, caption = "Male Block 4: Variables 16–20")

sample_scaled_pop <- scale_sample_based_on_population(df_anthros_f,pop_f%>% dplyr::select(-'Source',-Weight))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_f,sample_percentile)
write.csv(sample_anthro_percentile, "output/anthro_percentile_f.csv", row.names = FALSE)

anthro_summary_f <- sample_anthro_percentile

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_f %>% dplyr::select(1:5)
block_2 <- anthro_summary_f %>% dplyr::select(6:10)
block_3 <- anthro_summary_f %>% dplyr::select(11:15)
block_4 <- anthro_summary_f %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Female Block 1: Variables 1–5")
kable(block_2, caption = "Female Block 2: Variables 6–10")
kable(block_3, caption = "Female Block 3: Variables 11–15")
kable(block_4, caption = "Female Block 4: Variables 16–20")
```

# Bivariate Plot: Sitting Height vs. Combo Leg
The figure below presents a bivariate plot of *Sitting Height* against the synthetic *Combo Leg* variable for the study participants, overlaid on the broader reference population. This plot is a central tool in cockpit fit mapping as it illustrates not only the absolute dimensions of individuals, but more importantly, their *body proportions*—specifically the torso-to-limb relationship.

As described in Zehner (2001), two individuals with identical stature may have significantly different cockpit fit outcomes depending on whether they are long-torso/short-leg or short-torso/long-leg. This distinction can impact multiple aspects of cockpit accommodation, including over-the-nose vision, rudder pedal reach, and stick interference with the thigh. By plotting participants in this bivariate space, we can visually assess the range of proportional variability represented in the test sample, identify outliers, and determine whether the dataset includes edge-case anthropometries that could pose fit challenges.

This type of visualization is also useful for *selecting subjects* for physical mock-up testing or simulation studies, ensuring coverage of anthropometric edge cases that might otherwise be underrepresented if relying solely on univariate stature percentiles.
```{r}

clean_m <- df_anthros_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')
clean_f <- df_anthros_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')

data_m <- rbind(pop_m, clean_m)
# Plot
ggplot(data_m, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_m %>% as.data.frame(),
    aes(label = rownames(clean_m), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1, size = 3
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Female Participant Data vs. CFAS 2012 (90% CI)") +
  theme_minimal()

data_f <- rbind(pop_f, clean_f)
ggplot(data_f, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_f %>% as.data.frame(),
    aes(label = rownames(clean_f), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1, size = 3
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Female Participant Data vs. CFAS 2012 (90% CI)") +
  theme_minimal()


```

# Principal Component Analysis: Core Six Measures
To further explore the multivariate structure of anthropometric variability relevant to cockpit fit, this section applies Principal Component Analysis (PCA) using the six most critical cockpit-relevant body dimensions—commonly mentioned earlier. Principal Component 1 and 2 of the core six measures accounts for ~85% of the variability of the underlying dataset and is sufficient for accommodation modelling purposes. For this reason, we can discard the remaining principle components and apply a varimax rotation to the retained PC1 and PC2 loadings to improve the interpretability of the results.

These dimensions capture the major axes of cockpit interaction: overall size and torso:limb proportion. By performing PCA on the reference population (e.g., CFAS), we identify the principal axes along which body proportions vary, reducing redundancy and emphasizing body shape over raw size.

Each participant’s anthropometric profile is then projected into this reduced PCA space, allowing us to plot them relative to the broader population distribution. This enables:

- Identification of outlier body types (e.g., extreme limb-to-torso proportions),

- Assessment of whether the participant sample adequately spans a target accommodation level (ellipse boundary), and

- Support for subject selection in physical fit validation, ensuring inclusion of worst-case accommodation points.

```{r}

# Select measures of interests. Recommended 'Core Six'

pca_vars = c(
    "Sitting Height",
    "Eye Height - Sitting",
    "Acromial Height - Sitting",
    "Knee Height - Sitting",
    "Buttock-Knee Length",
    "Thumbtip Reach"
  )

# Define study vs pop data - Males

pop_pca <- data_m
study_pca <- clean_m

pop_pca <- pop_pca %>%
  dplyr::select(pca_vars
  ) %>%
  na.omit()

study_pca <- study_pca %>%
  dplyr::select(pca_vars) %>%
  na.omit()

# Perform PCA - MALE

scaled_data <- scale(pop_pca) # Standardize the population data (mean = 0, SD = 1)

pca_data <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="varimax")

study_scaled <- ScaleToPopulation(study_pca,pop_pca) %>% as.matrix() # scale study data per population
study_scores <- ScaleToPC(study_scaled,pca_data$weights) # calculate PC scores for study data

ellipse_frame <- AccommodationEllipse(90) # set accommodation ellipse level

pca_plot <- ggplot() +
   geom_point(data = pca_data$scores %>% as.data.frame(), aes(x = RC1, y = RC2), size = 1) +
   geom_point(data = study_scores %>% as.data.frame(), aes(x = RC1, y = RC2), shape = 21, size = 3,color="blue") +
   geom_path(data = ellipse_frame, aes(x=ellipse_frame[,1], y=ellipse_frame[,2]), color='red')+
  geom_label(data = study_scores %>% as.data.frame(), aes(label = rownames(study_scores),x = RC1,y=RC2), color = "blue", vjust = -0.5, hjust = 1, size = 3)+
  
  scale_x_continuous(limits = c(-3, 3)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-3, 3))+   # Define y-axis limits
     labs(
         x = "RC1",
         y = "RC2",
         title = "PC Scores(Varimax): Study vs. Population (Male)",
         subtitle = "Black: Population, Red: 90% Accommodation"
     )+
    theme_minimal() # Minimal theme for cleaner appearance
      
print(pca_data$loadings)
print(pca_plot)

```


```{r}

#load all the participant performacne data from GoogleSheets

df_onv <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-head_clear_pass_fail,-head_clear_mm)

df_onv_737 <- read_sheet("https://docs.google.com/spreadsheets/d/1q4_3hE1rEuWwfZEBP-a2KvRsFJBqM5GBcgHjXmiWA-4/edit?gid=1101471552#gid=1101471552") %>% as.data.frame()

df_head_clear <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-onv_deg)

df_shin <- read_sheet("https://docs.google.com/spreadsheets/d/1a-abUwfAivR8DNFgPDc2Ht7mFQ0ebO0C9q-vG3LxbbY/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1SicW4frwWsSooKwXwwccX8j4VLic3yP3nzLgLFoz5Dg/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_range_of_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1VTS-rYKKtNIpy1KneRvKB3fzVJ25YvdVLo3l9Cayq9M/edit?gid=0#gid=0") %>% as.data.frame()
 
df_rudder <- read_sheet("https://docs.google.com/spreadsheets/d/1w8L0ETVMvDVrFIsYAB5N1idFtRWpR8AfZq3mh6kZ6Fc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_hand_reach <- read_sheet("https://docs.google.com/spreadsheets/d/1MezpHsf-7rbU6M6C6czHL7ZJDAOgsHX63HWkZWBLItc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_controls <- read_sheet("https://docs.google.com/spreadsheets/d/1QnLAoSWwkXrCxc5orFyGn6PkcvkZnylNm4Erdpp2NsY/edit?gid=0#gid=0") %>% as.data.frame()

```

# Head Clearance

A linear model was used to examine how body dimensions relate to overhead clearance in the Bell 206 cockpit. The analysis found that sitting height is a strong predictor of available head clearance, with taller individuals generally having less space overhead. Waist depth was also included in the model but did not show a strong individual effect. The model explains nearly all of the variation in head clearance across participants. Full model results are included in the output below.

```{r}

#Join anthros

df <- df_head_clear %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Sitting Height`, df$head_clear_mm, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Sitting Height`, y = head_clear_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Head Clearance vs. Sitting Height",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Sitting Height (mm)",
    y = "Head Clearance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Sitting Height`, y = head_clear_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
  scale_y_reverse()+
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(head_clear_mm ~ `Sitting Height` + 
              `Waist Depth` +
              `Weight`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$head_clear_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$head_clear_mm_predicted,
  actual = df$head_clear_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Head Clearance = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Head Clearance",
    subtitle = subtitle_text,
    x = "Predicted Head Clearance (mm)",
    y = "Actual Head Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()

```

# Over the Nose Vision

A linear model was developed to explore how body dimensions influence over-the-nose vision in the Bell 206. The analysis found that eye height, sitting is strongly associated with ONV angle — individuals with taller seated eye heights tend to have better downward visibility. While waist depth was included in the model to account for the horizontal offset of the shoulder from the seat back, it did not show a strong statistical effect. Overall, the model explains a high proportion of the variation in ONV among participants. Full model details and statistics are provided in the code and output below.

```{r}

#Join anthros

df <- df_onv %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Eye Height - Sitting`, df$onv_deg, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Eye Height - Sitting`, y = onv_deg)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "External Vision vs. Eye Height (Sitting)",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Eye Height - Sitting (mm)",
    y = "External Vision Over the Nose (degrees)"
  ) +
  scale_y_reverse()+
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Eye Height - Sitting`, y = onv_deg),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(onv_deg ~ `Eye Height - Sitting` + 
              `Waist Depth`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Add predicted values to the original dataframe
df$onv_deg_predicted <- predict(step_model)

# Generate predicted values and confidence intervals
df$onv_deg_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$onv_deg_predicted,
  actual = df$onv_deg,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "ONV = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Over-the-Nose Vision (ONV)",
    subtitle = subtitle_text,
    x = "Predicted ONV (degrees)",
    y = "Actual ONV (degrees)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()


```

# Shin Clearance

Shin clearance was assessed using the minimum measured distance between the participant’s shins and the instrument panel across all pedal positions. Following the methodology adapted from Kennedy (2001) a regression analysis was performed to evaluate the predictive value of lower limb anthropometric dimensions. The Bell 206 instrument panel only extends over the inner-most leg (i.e., the left shin when seated in the right pilot seat)

Initial Pearson correlation analysis showed a strong negative correlation between Combo Leg Length and shin clearance (r = -0.95, *p* < 0.001), indicating that individuals with longer lower limbs are more likely to experience reduced clearance.

A stepwise linear regression confirmed that Combo Leg Length alone was the most predictive variable. The final model explained over 90% of the variance in shin clearance (*R²* = 0.91), with each additional millimetre of Combo Leg associated with a 0.39 mm decrease in clearance. Other candidate predictors, including Buttock-Knee Length and rudder pedal displacement, did not significantly improve model performance and were removed during model selection.

We also found that most participants experienced minimum clearance to their left shin with the right pedal depressed, while some experience minimum clearance when pedals neutral. Furthermost, it is believed that foot length may be a contributing factor as this effects the position of the anckle joint.

This result supports the use of Combo Leg as a proxy variable when assessing lower-limb accommodation in static cockpit configurations such as the Bell 206.

```{r}

# #Join anthros

df <- df_shin %>%
  mutate(
    ID = as.numeric(ID),
    min_clearance = pmin(neutral_clearance_mm,
                         full_left_active_mm, 
                         full_left_passive_mm, 
                         full_right_active_mm, 
                         full_right_passive_mm, 
                         na.rm = TRUE
                         )
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Combo Leg`, df$min_clearance, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Combo Leg`, y = min_clearance)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Shin Clearance vs. Combo Leg",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Combo Leg (Buttock Knee Length + Knee Height - Sitting) (mm)",
    y = "Minimum Shin Clearance"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Combo Leg`, y = min_clearance),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(min_clearance ~ `Buttock-Knee Length` +
              `Combo Leg`+ `Knee Height - Sitting` + rudder_mm, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$min_clearance_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$min_clearance_predicted,
  actual = df$min_clearance,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Shin Clearance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Shin Clearance",
    subtitle = subtitle_text,
    x = "Predicted Shin Clearance (mm)",
    y = "Actual Shin Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()


```

# Control Motion

A multivariate linear regression was conducted to explore which anthropometric factors influence the maximum forward position a participant can achieve on the cyclic control while seated in a Zone 1 posture (i.e., upright, no leaning). In this model, 100% represents full forward cyclic travel.

```{r}

#Join anthros

# Extract full forward and aft values from the control data
cyclic_limits <- df_range_of_motion %>%
  filter(adjustment == "cyclic_fwd") %>%
  dplyr::select(min, max) %>%
  slice(1)  # In case there's more than one row

df <- df_motion %>%
  mutate(
    ID = as.numeric(ID),
    cyclic_pct_fwd = ((cyclic_limits$max-fwd_deg)/(cyclic_limits$max-cyclic_limits$min))*100
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Thumbtip Reach`, df$cyclic_pct_fwd, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = cyclic_pct_fwd)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Cyclic Control Motion (% fwd) vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Cyclic Control Motion (% fwd)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = cyclic_pct_fwd),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(cyclic_pct_fwd ~ `Thumbtip Reach` + 
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$cyclic_pct_fwd_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$cyclic_pct_fwd_predicted,
  actual = df$cyclic_pct_fwd,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "fwd_deg = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Zone 1 Cyclic Fwd Reach (%)",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Fwd Cyclic (%)",
    y = "Actual Zone 1 Fwd Cyclic (%)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()



```

# Reach to Rudder Pedals

Rudder pedal position is a critical component of lower-body accommodation in cockpit fit mapping. The ability to achieve full rudder deflection—particularly with toe brake actuation—is essential for safe ground handling and coordinated flight. Following Zehner’s (2001) methodology, this section evaluates participants’ ability to meet the functional requirement for full rudder pedal reach with the seat various positions.

The omposite `Combo Leg` variable is reported. The rudder pedals were adjusted to the most forward position that the participant could still achieve full rudder deflection and brake application. Negative values represent a missed reach. 

```{r}

# #Join anthros

# Extract full forward and aft values from the control data
rudder_limits <- df_range_of_motion %>%
  filter(adjustment == "rudder") %>%
  dplyr::select(min, max) %>%
  slice(1)  # In case there's more than one row

df <- df_rudder %>%
  mutate(
    ID = as.numeric(ID),
    rudder_pct_fwd = (rudder_mm/(rudder_limits$max-rudder_limits$min))*100
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")

cor_test_result <- cor.test(df$`Combo Leg`, df$rudder_mm, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Combo Leg`, y = rudder_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Rudder Carriage Position vs. Combo Leg",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Combo Leg (Buttock Knee Length + Knee Height - Sitting) (mm)",
    y = "Maximum Fwd Rudder Carriage Position (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Combo Leg`, y = rudder_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(rudder_mm ~  `Combo Leg`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$rudder_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$rudder_mm_predicted,
  actual = df$rudder_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Rudder Position Forward = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Maximum Rudder Position",
    subtitle = subtitle_text,
    x = "Predicted Maximum Forward Rudder Carriage Position (mm)",
    y = "Actual Maximum Forward Rudder Carriage Position (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()


```

# Reach to Controls

## Zone 1 - LOW ROTOR RPM Push Button Annunciator

The analysis investigated how well participants could reach the LOW ROTOR RPM push button without leaning (Zone 1 posture). A negative correlation was found between thumbtip reach and the miss distance—how far short the participant’s reach fell. Specifically, individuals with shorter thumbtip reach tended to have larger miss distances. The correlation was statistically significant (r = -0.80, p = 0.016), indicating a strong inverse relationship.

A linear regression model confirmed that thumbtip reach was a significant predictor of reach success. For every additional millimetre of thumbtip reach, the miss distance decreased by approximately 0.32 mm. This single-variable model explained about 65% of the variation in reach performance (R² = 0.65), and adding other variables (such as acromial height) did not improve the model.


```{r}

#Join anthros

controls <- c(
  "low_rpm_mm",
  "ctrl_boost_mm"
)


df_reach_joined <- df_hand_reach %>%
  mutate(
    ID = as.numeric(ID)
    ) %>%
  pivot_longer(cols = controls, names_to = "control", values_to = "x-to") %>%
  left_join(df_controls, by = "control") %>% 
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID") %>%
    mutate(
      miss_mm = case_when(
        control_type == "thumb" ~ `x-to` - `left_x_to_thumb`,
        control_type == "finger" ~ `x-to` - `left_x_to_finger`,
        TRUE ~ NA_real_  # fallback in case of unexpected control_type
      ),
      equiv_thumbtip_reach = `x-to` + miss_mm
    )

# Account for depression activation of "finger" controls

df_reach_joined <- df_reach_joined %>%
  mutate(
    miss_mm = case_when(
      control_type == "finger" ~ miss_mm + 3, # button depression
      TRUE ~ miss_mm  # keep original value for all other types
    )
  )
```

```{r}

# Zone 1 - RPM

df <- df_reach_joined %>% filter(
  control == "low_rpm_mm",
  zone == 1
)

cor_test_result <- cor.test(df$miss_mm, df$`Thumbtip Reach`, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = miss_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Miss to Low RPM Button vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Zone 1 Miss Distance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = miss_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(miss_mm ~ `Thumbtip Reach` +
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$miss_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$miss_mm_predicted,
  actual = df$miss_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Miss Distance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Zone 1 Miss to LOW ROTOR Push Button",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Miss to LOW ROTOR Push Button (mm)",
    y = "Actual Zone 1 Miss to LOW ROTOR Push Button(mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()

```

## Zone 1 - Control Boost Toggle Switch

The analysis assessed whether body dimensions could predict participants’ ability to reach the Control Boost toggle switch without leaning (Zone 1 posture). The Pearson correlation between thumbtip reach and miss distance was moderately strong (r = -0.66), suggesting that longer thumbtip reach may be associated with better reach performance. However, this relationship did not reach statistical significance (p = 0.074), possibly due to the small sample size.

A linear regression model including thumbtip reach and acromial height accounted for about 60% of the variation in miss distance (R² = 0.60). Of the two predictors, thumbtip reach showed a borderline significant contribution (p = 0.058), with each additional millimetre of reach associated with a 0.85 mm reduction in miss distance. Acromial height was not a significant predictor.

These findings suggest that thumbtip reach may still be a relevant measure for reach performance, though the relationship in this case is weaker and less conclusive compared to other controls. Further data may help clarify this relationship.

```{r}
# Zone 1 - Control Boost

df <- df_reach_joined %>% filter(
  control == "ctrl_boost_mm",
  zone == 1
)

cor_test_result <- cor.test(df$miss_mm, df$`Thumbtip Reach`, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = miss_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Miss to Control Boost vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Zone 1 Miss Distance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = miss_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +

  theme_minimal()

# Fit linear model

model <- lm(miss_mm ~ `Thumbtip Reach` +
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$miss_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$miss_mm_predicted,
  actual = df$miss_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Miss Distance = ", round(coefs[1], 2),
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Zone 1 Miss to Control Boost Toggle Switch",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Miss to Control Boost Toggle Switch (mm)",
    y = "Actual Zone 1 Miss to Control Boost Toggle Switch"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()


```

# Boeing 737 Over the Nose Vision

We also took the opportunity to measure the over the nose vision of the Beoing 737 pilot seat which has horizontal and vertical adjustments. Notably, both vertical and horizontal adjustments rotate the seat about an axis and therefore affect both x and y coordinates of the seat reference point. Furthermore, the seat also includes a back rest recline adjustment. For simplicity, ONV were recorded at seat full up/aft, down/aft, and down/fwd. The full up/fwd position was not recorded because it was falsely thought to be inaccessible due to the overall difficulty in adjusting the seat position.

```{r}

df_seat_positions <- read_sheet("https://docs.google.com/spreadsheets/d/1ZP8djxCW8M4S3qmLSWnqe8YVQoUlXagu-mWTaeU3V0Q/edit?gid=0#gid=0") %>% as.data.frame()

#Join anthros

df <- df_onv_737 %>%
  mutate(
    ID = as.numeric(ID),
    seat_up_mm = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ 0,
      seat_up_step == 0 & seat_fwd_step == 1 ~ df_seat_positions$y_mm[df_seat_positions$pos == "down_fwd"] - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"],
      seat_up_step == 1 & seat_fwd_step == 0 ~ df_seat_positions$y_mm[df_seat_positions$pos == "up_aft"] - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"],
      seat_up_step == 1 & seat_fwd_step == 1 ~ df_seat_positions$y_mm[df_seat_positions$pos == "up_fwd"]  - df_seat_positions$y_mm[df_seat_positions$pos == "down_aft"]
    ),
    seat_fwd_mm = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ 0,
      seat_up_step == 0 & seat_fwd_step == 1 ~  df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "down_fwd"],
      seat_up_step == 1 & seat_fwd_step == 0 ~ df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "up_aft"],
      seat_up_step == 1 & seat_fwd_step == 1 ~ df_seat_positions$x_mm[df_seat_positions$pos == "down_aft"] - df_seat_positions$x_mm[df_seat_positions$pos == "up_fwd"]
    ),
    seat_pos = case_when(
      seat_up_step == 0 & seat_fwd_step == 0 ~ "down_aft",
      seat_up_step == 0 & seat_fwd_step == 1 ~ "down_fwd",
      seat_up_step == 1 & seat_fwd_step == 0 ~ "up_aft",
      seat_up_step == 1 & seat_fwd_step == 1 ~ "up_fwd",
    )
  ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")

df_UpAft <- df %>%
  filter(
    seat_up_step == 1,
    seat_fwd_step == 0,
    recline_up == 1
  ) 

cor_test_result <- cor.test(df_UpAft$`Eye Height - Sitting`, df_UpAft$onv_deg, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df_UpAft, aes(x = `Eye Height - Sitting`, y = onv_deg)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "External Vision vs. Eye Height (Sitting)",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Eye Height - Sitting (mm)",
    y = "External Vision Over the Nose (degrees)"
  ) +
  geom_text(
    data = df_UpAft %>% as.data.frame(),
    aes(label = ID, x = `Eye Height - Sitting`, y = onv_deg),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

df <- df %>%
  filter(
    recline_up == 1
  )

model <- lm(onv_deg ~ `Eye Height - Sitting` + 
              seat_up_step + 
              seat_fwd_step, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Add predicted values to the original dataframe
df$onv_deg_predicted <- predict(step_model)

# Generate predicted values and confidence intervals
df$onv_deg_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$onv_deg_predicted,
  actual = df$onv_deg,
  ID = df$ID,
  seat_pos = df$seat_pos
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "ONV = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual, color = seat_pos)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Over-the-Nose Vision (ONV)",
    subtitle = subtitle_text,
    x = "Predicted ONV (degrees)",
    y = "Actual ONV (degrees)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3,
    show.legend = FALSE
  ) +
  theme(
  plot.margin = margin(t = 10, r = 80, b = 10, l = 10)
) +
  theme_minimal()

subtitle_text

```


```{r}
sessionInfo()
```
