---
title: "Bell 206 Anthro Accommodation"
author: "Patrick Bickerton"
date: "2025-05-31"
output: 
  prettydoc::html_pretty:
    toc: true
    toc_depth: 2
    theme: hpstr
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The design and evaluation of crewstations, such as helicopter cockpits, must address the challenge of accommodating a diverse range of body sizes. In military aviation, this issue has traditionally been managed by setting anthropometric entry requirements that narrow the pool of eligible pilots. However, evolving policy and operational demands—such as efforts to diversify aircrew populations—have renewed focus on optimizing cockpit designs for broader anthropometric inclusion. This R Markdown document presents a cockpit accommodation mapping analysis for the Bell 206 Helicopter, leveraging the methodology presented by Zehner (2001). The aim is to provide both technical documentation and an instructional resource that integrates anthropometric data, analytical code, and visualization.

# Methodological Overview

The methodological framework used for this study mirrors the structured approach defined by Zehner (2001), comprising the following steps:

* Defining the User Population: We selected a representative anthropometric sample from the available dataset, filtered to reflect the demographic and physical characteristics of prospective rotary-wing pilots. This includes stature, sitting height, and buttock-knee length, which are known to influence cockpit accommodation.

* Identifying Operational Requirements: Functional reach, visibility (especially over-the-nose vision), and control actuation were defined as essential operational criteria for the Bell 206. These would normally be informed by pilot interviews, historical ergonomics literature, and observed control configurations in the aircraft. However, for the present effort, these were arbitrarily defined by the test team to prioritize the training opportunity.

* Cockpit Mapping: Anthropometric variables were mapped against cockpit features using regression modeling. Accommodation success was evaluated by comparing predicted values—such as eye height or functional reach—against thresholds necessary to operate the helicopter safely.

* Predicting Population-Level Accommodation: Using population percentile data and bivariate regression models, we estimated the percentage of the population likely to be accommodated within the existing cockpit geometry.

Each of these phases is documented in this R Markdown file, with corresponding code, figures, and summaries provided inline.

# Anthropometric Dataset Description
The analysis draws from a curated subset of anthropometric data representative of the potential user population. Data selection emphasized key dimensions affecting cockpit fit, including the "core six":

* Sitting Height, (for head clearance to overhead control panel),

* Eye Height, Sitting (for vision clearance),

* Acromial Height, Sitting (for control alignment and clearance assessments),

* Buttock-Knee Length (for legroom and pedal reach),

* Knee Height, Sitting (for legroom and pedal reach),

* Thumbtip Reach (for lateral and forward reach envelope),

Additional anthropometric measurements were taken for exploratory purposes

All data cleaning and filtering steps are documented in the accompanying code chunks. Where applicable, outlier handling and dimension normalization were performed to align with assumptions of multivariate modeling.

# Libraries and Custom Functions

Before proceeding with the analysis, we begin by loading the necessary R packages and sourcing a set of custom functions used across multiple anthropometric accommodation projects. These functions are modular and have been developed to streamline common tasks such as data cleaning, cockpit geometry transformation, percentile calculation, and visualization.

The following code chunk performs two key functions:

1. Load Required Libraries: Core packages such as tidyverse for data manipulation and plotting, readr and googlesheets 4 for file input, and ggplot2 for visualizations are loaded.

2. Source Custom Functions: Custom R scripts are sourced to make reusable functions available in the current environment. These scripts contain purpose-built code for cockpit fit assessments—such as functions to compute univariate percentiles of the participants compared to a population data set.

This initialization step ensures a consistent analytical environment and supports reproducibility across cockpit accommodation studies.

```{r}
# import the libraries
library(tidyr)
library(ggplot2)
library(readr)
library(dplyr)
library(psych) #for principle component analysis with VARIMAX rotation
library(googlesheets4) #to import custom dataset
library(knitr) # for displaying tables in knitted document
library(kableExtra)
library(stringr) # for data cleaning
library(MASS) # for stepwise regression

# import the libraries
source("Modules/AccomodationFunctions.R")
source("Modules/Libraries.R")
source("Modules/Tables.R")
```

# Loading Anthropometric Data from Google Sheets
To facilitate collaboration across a distributed team and ensure the analysis reflects the most up-to-date participant data, this project retrieves anthropometric measurements directly from a centralized Google Sheet using the googlesheets4 package. This approach enables near real-time updates without the need to manually redistribute CSV files or regenerate local datasets.

The use of googlesheets4 supports version control and reproducibility, particularly when this R Markdown file is deployed or shared through GitHub. When hosted in a GitHub repository, the analysis can be automatically re-rendered with the latest data, making it suitable for iterative cockpit fit evaluations or multi-phase studies.

The Google Sheet contains standardized anthropometric variables required for cockpit accommodation analysis, such as Sitting Eye Height, Buttock-Knee Length, Functional Arm Reach, and Shoulder Height. Access is authenticated securely through the user’s Google account, and the sheet can be configured with view-only or edit permissions to manage data integrity.

```{r}
# Import survey data
df_anthros <- read_sheet("https://docs.google.com/spreadsheets/d/1ivDEK3W4lSWOvc1rr_CDwM9fo-UZnU5sg26lxeQjKNU/edit?gid=0#gid=0")%>% as.data.frame()
rownames(df_anthros) <- df_anthros$ID


# Add combo leg
df_anthros <- df_anthros %>%
  mutate(
    'Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`,
    'Source' = "Study",
    'ID' = as.character(ID),
    `Weight` = round(Weight * 0.45359237,2)
  )

# Split sexes and output csv
df_anthros_m <- df_anthros %>% filter(Sex == 'M')
write.csv(df_anthros_m, "output/anthros_m.csv", row.names = FALSE)

df_anthros_f <- df_anthros %>% filter(Sex == 'F')
write.csv(df_anthros_f, "output/anthros_f.csv", row.names = FALSE)

```
# Loading Reference Population Dataset
To evaluate accommodation within the Bell 206 cockpit, participant measurements must be compared against a broader reference population. In this project, we use the *2012 Canadian Forces Anthropometric Survey (CFAS)* as the primary population dataset. The CFAS provides a comprehensive and high-resolution snapshot of modern military anthropometry, including key cockpit-relevant dimensions such as stature, sitting height, limb lengths, and functional reaches.

The reference dataset enables both univariate and multivariate comparisons to estimate the percentage of the military population that would be expected to achieve successful accommodation under defined operational criteria. While CFAS is used in this instance due to its relevance and completeness, the framework is designed to accept any alternative anthropometric dataset that includes the necessary variables. This modularity makes the analysis portable and adaptable for use with datasets such as ANSUR II, or CAESAR.

We also add the composite *combo leg* variable that sums buttock-knee length, knee height - sitting, that more accurately reflects leg reach and clearance constraints in a seated posture than any individual measure alone.

The dataset is typically stored locally in .csv and read into the R environment as follows:

```{r}
#Load Population Dataset
pop <- read_csv("Data/CFAS_2012.csv",show_col_types = FALSE) %>% dplyr::select(-`ID`,-`...1`)
pop <- pop %>%
  mutate(Source = "CFAS 2012")%>%
  mutate('Combo Leg' = `Knee Height - Sitting` + `Buttock-Knee Length`)
pop_m <- pop %>% filter(Sex== "Male", Service == "RCAF")
pop_f <- pop %>% filter(Sex== "Female")

common_columns <- intersect(names(pop),names(df_anthros)) #identify the common column names in the sample and population data files
pop_m <- pop_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records
pop_f <- pop_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex') #only use variables of interest to PCA. remove NA records

```


# Univariate Summary Tables: Raw and Percentile Comparisons
To support initial inspection of the participant dataset, this section generates univariate summary statistics for key anthropometric variables. These include both:

- Raw values (e.g., in millimetres), useful for direct dimensional interpretation and cockpit design reference, and

- Percentile rankings (%), computed by comparing each participant’s measurements against the appropriate reference population.

The percentile transformations allow for a normalized comparison of participant body dimensions relative to the broader military population and are especially useful when identifying outliers or individuals at accommodation risk due to body size extremes.


**Important Considerations for Population Comparison**

Care must be taken when selecting the appropriate population subset for percentile calculation to avoid violating statistical assumptions such as normality or representativeness. For instance:

- Sex Stratification: Male and female data should always be assessed separately due to fundamental differences in body size distributions.

- CFAS 2012 Sample Limitations: While the 2012 Canadian Forces Anthropometric Survey (CFAS) provides sufficient sample size to support stratified analysis of male subjects across military branches (Navy, Army, Air Force), the female sample sizes were not large enough within branches to yield statistically significant stratified comparisons. Therefore, female participant percentiles should only be assessed against the total female military population from the combined CFAS dataset.

- The output tables below provide summary statistics for each participant's measurements in both raw and percentile formats. These tables serve as a diagnostic tool to identify individuals who may fall outside accommodation envelopes for specific cockpit features.

```{r}
sample_scaled_pop <- scale_sample_based_on_population(df_anthros_m,pop_m %>% dplyr::select(-'Source',-Weight))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_m,sample_percentile)
write.csv(sample_anthro_percentile, "output/anthro_percentile_m.csv", row.names = FALSE)

anthro_summary_m <- sample_anthro_percentile 

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_m %>% dplyr::select(1:5)
block_2 <- anthro_summary_m %>% dplyr::select(6:10)
block_3 <- anthro_summary_m %>% dplyr::select(11:15)
block_4 <- anthro_summary_m %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Male Block 1: Variables 1–5")
kable(block_2, caption = "Male Block 2: Variables 6–10")
kable(block_3, caption = "Male Block 3: Variables 11–15")
kable(block_4, caption = "Male Block 4: Variables 16–20")

sample_scaled_pop <- scale_sample_based_on_population(df_anthros_f,pop_f%>% dplyr::select(-'Source',-Weight))
scaled_sample <- sample_scaled_pop$scaled_sample
sample_percentile <- sample_scaled_pop$sample_percentiles
sample_anthro_percentile <- percentile_table(df_anthros_f,sample_percentile)
write.csv(sample_anthro_percentile, "output/anthro_percentile_f.csv", row.names = FALSE)

anthro_summary_f <- sample_anthro_percentile

# Suppose 'my_wide_df' is your data frame with 20 columns
block_1 <- anthro_summary_f %>% dplyr::select(1:5)
block_2 <- anthro_summary_f %>% dplyr::select(6:10)
block_3 <- anthro_summary_f %>% dplyr::select(11:15)
block_4 <- anthro_summary_f %>% dplyr::select(16:19)

# In your .Rmd body
kable(block_1, caption = "Female Block 1: Variables 1–5")
kable(block_2, caption = "Female Block 2: Variables 6–10")
kable(block_3, caption = "Female Block 3: Variables 11–15")
kable(block_4, caption = "Female Block 4: Variables 16–20")
```

# Bivariate Plot: Sitting Height vs. Combo Leg
The figure below presents a bivariate plot of *Sitting Height* against the synthetic *Combo Leg* variable for the study participants, overlaid on the broader reference population. This plot is a central tool in cockpit fit mapping as it illustrates not only the absolute dimensions of individuals, but more importantly, their *body proportions*—specifically the torso-to-limb relationship.

As described in Zehner (2001), two individuals with identical stature may have significantly different cockpit fit outcomes depending on whether they are long-torso/short-leg or short-torso/long-leg. This distinction can impact multiple aspects of cockpit accommodation, including over-the-nose vision, rudder pedal reach, and stick interference with the thigh. By plotting participants in this bivariate space, we can visually assess the range of proportional variability represented in the test sample, identify outliers, and determine whether the dataset includes edge-case anthropometries that could pose fit challenges.

This type of visualization is also useful for *selecting subjects* for physical mock-up testing or simulation studies, ensuring coverage of anthropometric edge cases that might otherwise be underrepresented if relying solely on univariate stature percentiles.
```{r}

clean_m <- df_anthros_m %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')
clean_f <- df_anthros_f %>% dplyr::select(all_of(common_columns)) %>% dplyr::select(-'Sex')

data_m <- rbind(pop_m, clean_m)
# Plot
ggplot(data_m, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_m %>% as.data.frame(),
    aes(label = rownames(clean_m), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1, size = 3
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Female Participant Data vs. CFAS 2012 (90% CI)") +
  theme_minimal()

data_f <- rbind(pop_f, clean_f)
ggplot(data_f, aes(x = `Combo Leg`, y = `Sitting Height`)) +
  geom_point(aes(fill = Source),
             shape = 21, size = 3, stroke = 0.5) +

  # Label only the Study data with plain text (no box). Use geom_label for text + box
  geom_label(
    data = clean_f %>% as.data.frame(),
    aes(label = rownames(clean_f), x = `Combo Leg`, y = `Sitting Height`),
    vjust = -0.5, hjust = 1, size = 3
  ) +

  # Ellipse around all points
  stat_ellipse(level = 0.9, color = 'red') +

  # Titles and theme
  labs(title = "Female Participant Data vs. CFAS 2012 (90% CI)") +
  theme_minimal()


```

# Principal Component Analysis: Core Six Measures
To further explore the multivariate structure of anthropometric variability relevant to cockpit fit, this section applies Principal Component Analysis (PCA) using the six most critical cockpit-relevant body dimensions—commonly mentioned earlier. Principal Component 1 and 2 of the core six measures accounts for ~85% of the variability of the underlying dataset and is sufficient for accommodation modelling purposes. For this reason, we can discard the remaining principle components and apply a varimax rotation to the retained PC1 and PC2 loadings to improve the interpretability of the results.

These dimensions capture the major axes of cockpit interaction: overall size and torso:limb proportion. By performing PCA on the reference population (e.g., CFAS), we identify the principal axes along which body proportions vary, reducing redundancy and emphasizing body shape over raw size.

Each participant’s anthropometric profile is then projected into this reduced PCA space, allowing us to plot them relative to the broader population distribution. This enables:

- Identification of outlier body types (e.g., extreme limb-to-torso proportions),

- Assessment of whether the participant sample adequately spans a target accommodation level (ellipse boundary), and

- Support for subject selection in physical fit validation, ensuring inclusion of worst-case accommodation points.

```{r}

# Select measures of interests. Recommended 'Core Six'

pca_vars = c(
    "Sitting Height",
    "Eye Height - Sitting",
    "Acromial Height - Sitting",
    "Knee Height - Sitting",
    "Buttock-Knee Length",
    "Thumbtip Reach"
  )

# Define study vs pop data - Males

pop_pca <- data_m
study_pca <- clean_m

pop_pca <- pop_pca %>%
  dplyr::select(pca_vars
  ) %>%
  na.omit()

study_pca <- study_pca %>%
  dplyr::select(pca_vars) %>%
  na.omit()

# Perform PCA - MALE

scaled_data <- scale(pop_pca) # Standardize the population data (mean = 0, SD = 1)

pca_data <- principal(scaled_data,nfactors=2,covar=TRUE,rotate="varimax")

study_scaled <- ScaleToPopulation(study_pca,pop_pca) %>% as.matrix() # scale study data per population
study_scores <- ScaleToPC(study_scaled,pca_data$weights) # calculate PC scores for study data

ellipse_frame <- AccommodationEllipse(90) # set accommodation ellipse level

pca_plot <- ggplot() +
   geom_point(data = pca_data$scores %>% as.data.frame(), aes(x = RC1, y = RC2), size = 1) +
   geom_point(data = study_scores %>% as.data.frame(), aes(x = RC1, y = RC2), shape = 21, size = 3,color="blue") +
   geom_path(data = ellipse_frame, aes(x=ellipse_frame[,1], y=ellipse_frame[,2]), color='red')+
  geom_label(data = study_scores %>% as.data.frame(), aes(label = rownames(study_scores),x = RC1,y=RC2), color = "blue", vjust = -0.5, hjust = 1, size = 3)+
  
  scale_x_continuous(limits = c(-3, 3)) +  # Define x-axis limits
  scale_y_continuous(limits = c(-3, 3))+   # Define y-axis limits
     labs(
         x = "RC1",
         y = "RC2",
         title = "PC Scores(Varimax): Study vs. Population (Male)",
         subtitle = "Black: Population, Red: 90% Accommodation"
     )+
    theme_minimal() # Minimal theme for cleaner appearance
      
print(pca_data$loadings)
print(pca_plot)

```


```{r}

#load all the participant performacne data from GoogleSheets

df_onv <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-head_clear_pass_fail,-head_clear_mm)

df_head_clear <- read_sheet("https://docs.google.com/spreadsheets/d/1S44aRvgLbkFPny4hoekD1MWWY9uoMoWtq0UUjVZzR9A/edit?gid=1101471552#gid=1101471552") %>% as.data.frame() %>% dplyr::select(-seat_fwd_step,-seat_up_mm,-onv_deg)

df_shin <- read_sheet("https://docs.google.com/spreadsheets/d/1a-abUwfAivR8DNFgPDc2Ht7mFQ0ebO0C9q-vG3LxbbY/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1SicW4frwWsSooKwXwwccX8j4VLic3yP3nzLgLFoz5Dg/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_range_of_motion <- read_sheet("https://docs.google.com/spreadsheets/d/1VTS-rYKKtNIpy1KneRvKB3fzVJ25YvdVLo3l9Cayq9M/edit?gid=0#gid=0") %>% as.data.frame()
 
df_rudder <- read_sheet("https://docs.google.com/spreadsheets/d/1w8L0ETVMvDVrFIsYAB5N1idFtRWpR8AfZq3mh6kZ6Fc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

df_hand_reach <- read_sheet("https://docs.google.com/spreadsheets/d/1MezpHsf-7rbU6M6C6czHL7ZJDAOgsHX63HWkZWBLItc/edit?gid=96497919#gid=96497919") %>% as.data.frame()

```

# Head Clearance

A linear model was used to examine how body dimensions relate to overhead clearance in the Bell 206 cockpit. The analysis found that sitting height is a strong predictor of available head clearance, with taller individuals generally having less space overhead. Waist depth was also included in the model but did not show a strong individual effect. The model explains nearly all of the variation in head clearance across participants. Full model results are included in the output below.

```{r}

#Join anthros

df <- df_head_clear %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Sitting Height`, df$head_clear_mm, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Sitting Height`, y = head_clear_mm)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Head Clearance vs. Sitting Height",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Sitting Height (mm)",
    y = "Head Clearance (mm)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Sitting Height`, y = head_clear_mm),
    vjust = -1, hjust = 1, size = 3
  ) +
  scale_y_reverse()+
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(head_clear_mm ~ `Sitting Height` + 
              `Waist Depth` +
              `Weight`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$head_clear_mm_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$head_clear_mm_predicted,
  actual = df$head_clear_mm,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "Head Clearance = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Head Clearance",
    subtitle = subtitle_text,
    x = "Predicted Head Clearance (mm)",
    y = "Actual Head Clearance (mm)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()

```

# Over the Nose Vision

A linear model was developed to explore how body dimensions influence over-the-nose vision in the Bell 206. The analysis found that eye height, sitting is strongly associated with ONV angle — individuals with taller seated eye heights tend to have better downward visibility. While waist depth was included in the model to account for the horizontal offset of the shoulder from the seat back, it did not show a strong statistical effect. Overall, the model explains a high proportion of the variation in ONV among participants. Full model details and statistics are provided in the code and output below.

```{r}

#Join anthros

df <- df_onv %>%
  mutate(ID = as.numeric(ID)) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Eye Height - Sitting`, df$onv_deg, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Eye Height - Sitting`, y = onv_deg)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "External Vision vs. Eye Height (Sitting)",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Eye Height - Sitting (mm)",
    y = "External Vision Over the Nose (degrees)"
  ) +
  scale_y_reverse()+
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Eye Height - Sitting`, y = onv_deg),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(onv_deg ~ `Eye Height - Sitting` + 
              `Waist Depth`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Add predicted values to the original dataframe
df$onv_deg_predicted <- predict(step_model)

# Generate predicted values and confidence intervals
df$onv_deg_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$onv_deg_predicted,
  actual = df$onv_deg,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "ONV = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Over-the-Nose Vision (ONV)",
    subtitle = subtitle_text,
    x = "Predicted ONV (degrees)",
    y = "Actual ONV (degrees)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()


```

# Shin Clearance

```{r}

# #Join anthros
# 
# df <- df_shin %>%
#   mutate(ID = as.numeric(ID)) %>%
#   left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")
# 
# 
# cor_test_result <- cor.test(df$`Combo Leg`, df$full_right_passive_mm, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# # Print detailed summary
# print(cor_test_result)
# 
# ggplot(df, aes(x = `Combo Leg`, y = full_right_passive_mm)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "Shin Clearance vs. Combo Leg",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Combo Leg (Buttock Knee Length + Knee Height - Sitting) (mm)",
#     y = "Shin Clearance"
#   ) +
#   geom_text(
#     data = df %>% as.data.frame(),
#     aes(label = ID, x = `Combo Leg`, y = full_right_passive_mm),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
# 
# # Fit linear model
# 
# model <- lm(full_right_passive_mm ~ `Buttock-Knee Length` + 
#               `Combo Leg`+ `Knee Height - Sitting`, data = df)
# step_model <- stepAIC(model, direction = "both")
# summary(step_model)
# 
# # Generate predicted values and confidence intervals
# df$full_right_passive_mm_predicted <- predict(step_model)
# pred_frame <- data.frame(
#   predicted = df$full_right_passive_mm_predicted,
#   actual = df$full_right_passive_mm,
#   ID = df$ID
# )
# 
# # Extract coefficients and R-squared
# coefs <- coef(step_model)
# eq <- paste0(
#   "Shin Clearance = ", round(coefs[1], 2), 
#   ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
# )
# 
# if (length(coefs) > 2) {
#   for (i in 3:length(coefs)) {
#     eq <- paste0(
#       eq,
#       ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
#     )
#   }
# }
# 
# r_squared <- summary(step_model)$r.squared
# subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))
# 
# ggplot(pred_frame, aes(x = predicted, y = actual)) +
#   geom_point(size = 3, color = "steelblue") +
#   geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
#   geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
#   labs(
#     title = "Predicted vs Actual Shin Clearance",
#     subtitle = subtitle_text,
#     x = "Predicted Shin Clearance (mm)",
#     y = "Actual Shin Clearance (mm)"
#   ) +
#   geom_text(
#     data = pred_frame %>% as.data.frame(),
#     aes(label = ID, x = predicted, y = actual),
#     vjust = -1, hjust = 1, size = 3
#   ) +
#   theme(
#   plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
# ) +
#   theme_minimal()


```

# Control Motion

A multivariate linear regression was conducted to explore which anthropometric factors influence the maximum forward position a participant can achieve on the cyclic control while seated in a Zone 1 posture (i.e., upright, no leaning). In this model, 100% represents full forward cyclic travel.

```{r}

#Join anthros

# Extract full forward and aft values from the control data
cyclic_limits <- df_range_of_motion %>%
  filter(adjustment == "cyclic_fwd") %>%
  dplyr::select(min, max) %>%
  slice(1)  # In case there's more than one row

df <- df_motion %>%
  mutate(
    ID = as.numeric(ID),
    cyclic_pct_fwd = ((cyclic_limits$max-fwd_deg)/(cyclic_limits$max-cyclic_limits$min))*100
    ) %>%
  left_join(df_anthros %>% mutate(ID = as.numeric(ID)), by = "ID")


cor_test_result <- cor.test(df$`Thumbtip Reach`, df$cyclic_pct_fwd, method = "pearson")
cor_value <- round(cor_test_result$estimate, 2)

# Print detailed summary
print(cor_test_result)

ggplot(df, aes(x = `Thumbtip Reach`, y = cyclic_pct_fwd)) +
  geom_point(size = 3, color = "steelblue") +
  labs(
    title = "Zone 1 Cyclic Control Motion (% fwd) vs. Thumbtip Reach",
    subtitle = paste0("Pearson correlation: r = ", cor_value),
    x = "Thumbtip Reach (mm)",
    y = "Cyclic Control Motion (% fwd)"
  ) +
  geom_text(
    data = df %>% as.data.frame(),
    aes(label = ID, x = `Thumbtip Reach`, y = cyclic_pct_fwd),
    vjust = -1, hjust = 1, size = 3
  ) +
# Correlation line with 95% CI
  geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
  
  theme_minimal()

# Fit linear model

model <- lm(cyclic_pct_fwd ~ `Thumbtip Reach` + 
              `Acromial Height - Sitting`, data = df)
step_model <- stepAIC(model, direction = "both")
summary(step_model)

# Generate predicted values and confidence intervals
df$cyclic_pct_fwd_predicted <- predict(step_model)
pred_frame <- data.frame(
  predicted = df$cyclic_pct_fwd_predicted,
  actual = df$cyclic_pct_fwd,
  ID = df$ID
)

# Extract coefficients and R-squared
coefs <- coef(step_model)
eq <- paste0(
  "fwd_deg = ", round(coefs[1], 2), 
  ifelse(coefs[2] < 0, " - ", " + "), abs(round(coefs[2], 2)), " × ", names(coefs)[2]
)

if (length(coefs) > 2) {
  for (i in 3:length(coefs)) {
    eq <- paste0(
      eq,
      ifelse(coefs[i] < 0, " - ", " + "), abs(round(coefs[i], 2)), " × ", names(coefs)[i]
    )
  }
}

r_squared <- summary(step_model)$r.squared
subtitle_text <- paste(eq, sprintf("  |  R² = %.2f", r_squared))

ggplot(pred_frame, aes(x = predicted, y = actual)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, level = 0.95, color = "black", fill = "lightblue", linetype = "solid") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Predicted vs Actual Zone 1 Cyclic Fwd Reach (%)",
    subtitle = subtitle_text,
    x = "Predicted Zone 1 Fwd Cyclic (%)",
    y = "Actual Zone 1 Fwd Cyclic (%)"
  ) +
  geom_text(
    data = pred_frame %>% as.data.frame(),
    aes(label = ID, x = predicted, y = actual),
    vjust = -1, hjust = 1, size = 3
  ) +
  theme(
  plot.margin = margin(t = 10, r = 50, b = 10, l = 10)
) +
  theme_minimal()



```

```{r}

# df_performance <- df_performance %>%
#   rename(
#     c('Fwd' = 'DERP_Down'),
#     c('Up' = 'DERP_Up'),
#     c('ID' = 'Participant')
#   ) %>%
#     mutate(
#     Up = Up * 10, # cockpit data sheets in cm
#     Fwd = Fwd * 10, # cockpit data sheets in cm
#     ID = as.character(ID)
#   ) %>%
#     mutate(
#     Up = if_else(
#       `Seat Pos` %in% c("Seat full down/aft", "Seat full down/fwd", 
#                         "Seat full up/aft", "Seat full up/fwd"),
#       case_when(
#         `Seat Pos` == "Seat full down/aft" ~ 398,
#         `Seat Pos` == "Seat full down/fwd" ~ 398,
#         `Seat Pos` == "Seat full up/aft" ~ 550,
#         `Seat Pos` == "Seat full up/fwd" ~ 550
#       ),
#       Up  # assuming Up is already numeric
#     ),
#     Fwd = if_else(
#       `Seat Pos` %in% c("Seat full down/aft", "Seat full down/fwd", 
#                         "Seat full up/aft", "Seat full up/fwd"),
#       case_when(
#         `Seat Pos` == "Seat full down/aft" ~ 0,
#         `Seat Pos` == "Seat full down/fwd" ~ 180+30,
#         `Seat Pos` == "Seat full up/aft" ~ 0,
#         `Seat Pos` == "Seat full up/fwd" ~ 180+30
#       ),
#       Fwd
#     )
#   )
# 
# df_vision <- df_performance %>% dplyr::select(ID,Seat, Friend_Hos, `Seat Pos`, Up, Fwd, Ext_Vision)
# 
# # fill in seat positions
# 
# df_vision_wider <- df_vision %>%
#   dplyr::select(
#     -Up,-Fwd
#   ) %>%
#   pivot_wider(
#     names_from = `Seat Pos`,
#     values_from = Ext_Vision
#   )
# 
# df_vision_friendly <- df_vision %>% filter(Friend_Hos == "- FRIENDLY", Seat == "LEFT SEAT")
# df_vision_hostile <- df_vision %>% filter(Friend_Hos == "- HOSTILE", Seat == "LEFT SEAT")
# 
# # FUll UP / AFT
# 
# vision_plot <- df_vision_friendly %>% 
#   left_join (df_anthros,by = 'ID') %>%
#   filter(
#     `Seat Pos` == "Seat full up/aft"
#   )
# 
# cor_test_result <- cor.test(vision_plot$`Eye Height - Sitting`, vision_plot$Ext_Vision, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# # Print detailed summary
# print(cor_test_result)
# 
# ggplot(vision_plot, aes(x = `Eye Height - Sitting`, y = Ext_Vision)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "External Vision vs. Eye Height (Sitting) (FULL UP/AFT)",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Eye Height - Sitting (mm)",
#     y = "External Vision Over the Nose (degrees)"
#   ) +
#   scale_x_continuous(
#     limits = c(600, 900)
#   ) +
#   scale_y_continuous(
#     limits = c(-20,0)
#   ) +
#   scale_y_reverse()+
#   geom_text(
#     data = vision_plot %>% as.data.frame(),
#     aes(label = Name, x = `Eye Height - Sitting`, y = Ext_Vision),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
# 
# # FUll DERP
# 
# vision_plot <- df_vision_friendly %>% 
#   left_join (df_anthros,by = 'ID') %>%
#   filter(
#     `Seat Pos` == "Seat at DERP"
#   )
# 
# cor_test_result <- cor.test(vision_plot$`Eye Height - Sitting`, vision_plot$Ext_Vision, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# # Print detailed summary
# print(cor_test_result)
# 
# ggplot(vision_plot, aes(x = `Eye Height - Sitting`, y = Ext_Vision)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "External Vision vs. Eye Height (Sitting) (DERP)",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Eye Height - Sitting (mm)",
#     y = "External Vision Over the Nose (degrees)"
#   ) +
#   scale_x_continuous(
#     limits = c(600, 900)
#   ) +
#   scale_y_continuous(
#     limits = c(-20,0)
#   ) +
#   scale_y_reverse()+
#   geom_text(
#     data = vision_plot %>% as.data.frame(),
#     aes(label = Name, x = `Eye Height - Sitting`, y = Ext_Vision),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()

```

# Reach to Rudder Pedals

Rudder pedal position is a critical component of lower-body accommodation in cockpit fit mapping. The ability to achieve full rudder deflection—particularly with toe brake actuation—is essential for safe ground handling and coordinated flight. Following Zehner’s (2001) methodology, this section evaluates participants’ ability to meet the functional requirement for full rudder pedal reach with the seat various positions.

The omposite `Combo Leg` variable is reported. The rudder pedals were adjusted to the most forward position that the participant could still achieve full rudder deflection and brake application. Negative values represent a missed reach. 
```{r}
# Rudder Pedal Reach

# df_rudder <- df_performance %>%
#   dplyr::select(
#     ID,Seat, Friend_Hos, `Seat Pos`, Up, Fwd, Rudder_FF
#     ) %>%
#   filter(
#     Seat == "LEFT SEAT",
#     Friend_Hos == "- FRIENDLY"
#   )
# 
# df_rudder <- df_rudder %>% 
#   mutate(
#     Rudder_FF_chr = as.character(Rudder_FF),  # safely coerce to character
#     Rudder_FF_num = suppressWarnings(as.numeric(Rudder_FF_chr)),  # safely coerce numeric
#     PassFail = case_when(
#       !is.na(Rudder_FF_num) & Rudder_FF_num >= 0 ~ "Pass",
#       !is.na(Rudder_FF_num) & Rudder_FF_num < 0  ~ "Fail",
#       grepl("fail", Rudder_FF_chr, ignore.case = TRUE) ~ "Fail",
#       TRUE ~ NA_character_
#     )
#   ) %>%
#     left_join (df_anthros,by = 'ID')
# 
# rudder_plot <- df_rudder %>%
#   filter(
#     `Seat Pos` == "Seat full up/aft"
#   )
# 
# cor_test_result <- cor.test(rudder_plot$`Combo Leg`, rudder_plot$Rudder_FF_num, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# ggplot(rudder_plot, aes(x = `Combo Leg`, y = Rudder_FF_num)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "Further Forward Rudder Pedal Adjustment (Full Up / Full Aft)",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Combo Leg (mm)",
#     y = "Rudder Pedal Setting (in)"
#   )+
#   geom_text(
#     data = rudder_plot %>% as.data.frame(),
#     aes(label = Name, x = `Combo Leg`, y = Rudder_FF_num),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
# 
# rudder_plot <- df_rudder %>%
#   filter(
#     `Seat Pos` == "Seat full down/aft"
#   )
# 
# cor_test_result <- cor.test(rudder_plot$`Combo Leg`, rudder_plot$Rudder_FF_num, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# ggplot(rudder_plot, aes(x = `Combo Leg`, y = Rudder_FF_num)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "Further Forward Rudder Pedal Adjustment (Full Down / Full Aft)",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Combo Leg (mm)",
#     y = "Rudder Pedal Setting (in)"
#   )+
#   geom_text(
#     data = rudder_plot %>% as.data.frame(),
#     aes(label = Name, x = `Combo Leg`, y = Rudder_FF_num),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
# 
# rudder_plot <- df_rudder %>%
#   filter(
#     `Seat Pos` == "Seat full up/fwd"
#   )
# 
# cor_test_result <- cor.test(rudder_plot$`Combo Leg`, rudder_plot$Rudder_FF_num, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# ggplot(rudder_plot, aes(x = `Combo Leg`, y = Rudder_FF_num)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "Further Forward Rudder Pedal Adjustment (Full Up / Full Fwd)",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Combo Leg (mm)",
#     y = "Rudder Pedal Setting (in)"
#   )+
#   geom_text(
#     data = rudder_plot %>% as.data.frame(),
#     aes(label = Name, x = `Combo Leg`, y = Rudder_FF_num),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
```

```{r}
# Reach to controls

# df_reach <- df_performance %>% 
#   dplyr::select(
#     ID,Seat, Friend_Hos, `Seat Pos`, Up, Fwd, Master_Caution...8, `CNE/CB`, LandGear_LP, Aux_Pump, LP_pilot, APU, Control_boost, Fire_panel, Throttle_Quad, TQA, Wing_Flap_Ctrl, SEP, SRCH
#     ) %>%
#   filter(
#     Seat == "LEFT SEAT",
#     Friend_Hos == "- FRIENDLY"
#   )
# 
# df_reach_AUX <- df_reach %>% 
#   dplyr::select(ID, `Seat Pos`, Aux_Pump, Up, Fwd) %>%
#   mutate(
#     Aux_Pump = as.character(Aux_Pump),  # Coerce to character first
#     Aux_Pump = str_trim(Aux_Pump),      # Remove whitespace (optional but helpful)
#     Aux_Pump = case_when(
#       Aux_Pump %in% c("no data", "NULL", "") ~ NA_character_,
#       TRUE ~ Aux_Pump
#     )
#   ) %>%
#   distinct() %>%  # optional, removes duplicates
#   pivot_wider(
#     names_from = `Seat Pos`,
#     values_from = Aux_Pump
#   )
# 
# # estimate pass reaches for ID 5 and others based on similar controls
# 
# df_reach_AUX <- df_reach_AUX %>%
#   mutate(
#     Pass = as.numeric(`Seat at DERP`),
#     Pass = if_else(ID == 5, 15.2, Pass),
#     Pass = if_else(ID == 11, 14.7, Pass),
#     
#     # Coerce columns to numeric before conditional replacement
#     `Seat full up/aft` = if_else(ID == 11, 14.7, as.numeric(`Seat full up/aft`)),
#     `Seat full up/fwd` = if_else(ID == 11, 14.7, as.numeric(`Seat full up/fwd`)),
#     `Seat full down/fwd` = if_else(ID == 11, 14.7, as.numeric(`Seat full down/fwd`))
#   )
# 
# df_reach_AUX <- df_reach_AUX %>%
#   mutate(
#     miss_DERP = as.numeric(`Seat at DERP`) - Pass,  # would be zero
#     miss_UpAft = as.numeric(`Seat full up/aft`) - Pass,  # would be zero
#     miss_UpFwd = as.numeric(`Seat full up/fwd`) - Pass,  # would be zero
#     miss_DownAft = as.numeric(`Seat full down/aft`) - Pass,  # would be zero
#     miss_DownFwd = as.numeric(`Seat full down/fwd`) - Pass  # would be zero
#   )
# 
# df_reach_AUX <- df_reach_AUX %>%
#     left_join (df_anthros,by = 'ID')

# predictor <- df_reach_AUX$`Thumbtip Reach`+ df_reach_AUX$`Acromial Height - Sitting`
# seat_cond <- df_reach_AUX$miss_DownAft
# 
# cor_test_result <- cor.test(predictor, seat_cond, method = "pearson")
# cor_value <- round(cor_test_result$estimate, 2)
# 
# ggplot(df_reach_AUX, aes(x = predictor, y = seat_cond)) +
#   geom_point(size = 3, color = "steelblue") +
#   labs(
#     title = "Reach Miss of AUX Pump",
#     subtitle = paste0("Pearson correlation: r = ", cor_value),
#     x = "Reach Estimate (mm)",
#     y = "Reach / Miss (cm)"
#   )+
#   geom_text(
#     data = df_reach_AUX %>% as.data.frame(),
#     aes(label = Name, x = predictor, y = seat_cond),
#     vjust = -1, hjust = 1, size = 3
#   ) +
# # Correlation line with 95% CI
#   geom_smooth(method = "lm", se = TRUE,level = 0.95, color = "blue", linewidth = 0.8) +
#   
#   theme_minimal()
# 
# df_reach_AUX_fail <- df_reach_AUX %>%
#   filter(
#     ID %in% c(5,6,8,10)
#   )

# model <- lm(miss_UpAft ~ `Thumbtip Reach` + `Acromial Height - Sitting` + `Biacromial Breadth` + Stature + , data = df_reach_AUX_fail)
# step_model <- stepAIC(model, direction = "both")
# summary(step_model)
# 
# predictions <- predict(step_model, interval = "confidence", level = 0.90)
# 
# # Combine actual and predicted values into a new dataframe
# plot_df <- df_reach_AUX_fail %>%
#   mutate(
#     actual = miss_UpAft,
#     predicted = predictions[, "fit"],
#     lower90 = predictions[, "lwr"],
#     upper90 = predictions[, "upr"]
#   )
# 
# # Plot
# ggplot(plot_df, aes(x = predicted, y = actual)) +
#   geom_point(color = "steelblue", size = 3) +
#   geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
#   geom_ribbon(aes(ymin = lower90, ymax = upper90), fill = "lightblue", alpha = 0.3) +
#   labs(
#     title = "Predicted vs Actual Reach Miss Distance",
#     x = "Predicted miss_UpAft",
#     y = "Actual miss_UpAft"
#   ) +
#   theme_minimal()
#   
# 
# model <- lm(`Seat full up/aft` ~ `Thumbtip Reach`, data = df_reach_AUX_fail)
# summary(model)
# plot(model)


```



```{r}
sessionInfo()
```
